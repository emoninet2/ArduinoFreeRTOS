
Blink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003c  00800100  000012f8  0000138c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000012f8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000044b  0080013c  0080013c  000013c8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000013c8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000013f8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000410  00000000  00000000  00001438  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000083cd  00000000  00000000  00001848  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000018a8  00000000  00000000  00009c15  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000192e  00000000  00000000  0000b4bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b7c  00000000  00000000  0000cdec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000222b  00000000  00000000  0000d968  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004123  00000000  00000000  0000fb93  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003f0  00000000  00000000  00013cb6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5d 00 	jmp	0xba	; 0xba <__ctors_end>
       4:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
       8:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
       c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      10:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      14:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      18:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      1c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      20:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      24:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      28:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      2c:	0c 94 50 02 	jmp	0x4a0	; 0x4a0 <__vector_11>
      30:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      34:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      38:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      3c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      40:	0c 94 38 08 	jmp	0x1070	; 0x1070 <__vector_16>
      44:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      48:	0c 94 43 07 	jmp	0xe86	; 0xe86 <__vector_18>
      4c:	0c 94 75 07 	jmp	0xeea	; 0xeea <__vector_19>
      50:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      54:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      58:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      5c:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      60:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>
      64:	0c 94 85 00 	jmp	0x10a	; 0x10a <__bad_interrupt>

00000068 <__trampolines_end>:
      68:	00 00       	nop
      6a:	00 08       	sbc	r0, r0
      6c:	00 02       	muls	r16, r16
      6e:	01 00       	.word	0x0001	; ????
      70:	00 03       	mulsu	r16, r16
      72:	04 07       	cpc	r16, r20
	...

0000007c <digital_pin_to_bit_mask_PGM>:
      7c:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
      8c:	04 08 10 20                                         ... 

00000090 <digital_pin_to_port_PGM>:
      90:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
      a0:	03 03 03 03                                         ....

000000a4 <port_to_output_PGM>:
      a4:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

000000ae <port_to_mode_PGM>:
      ae:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

000000b8 <__ctors_start>:
      b8:	a5 07       	cpc	r26, r21

000000ba <__ctors_end>:
      ba:	11 24       	eor	r1, r1
      bc:	1f be       	out	0x3f, r1	; 63
      be:	cf ef       	ldi	r28, 0xFF	; 255
      c0:	d8 e0       	ldi	r29, 0x08	; 8
      c2:	de bf       	out	0x3e, r29	; 62
      c4:	cd bf       	out	0x3d, r28	; 61

000000c6 <__do_copy_data>:
      c6:	11 e0       	ldi	r17, 0x01	; 1
      c8:	a0 e0       	ldi	r26, 0x00	; 0
      ca:	b1 e0       	ldi	r27, 0x01	; 1
      cc:	e8 ef       	ldi	r30, 0xF8	; 248
      ce:	f2 e1       	ldi	r31, 0x12	; 18
      d0:	02 c0       	rjmp	.+4      	; 0xd6 <__do_copy_data+0x10>
      d2:	05 90       	lpm	r0, Z+
      d4:	0d 92       	st	X+, r0
      d6:	ac 33       	cpi	r26, 0x3C	; 60
      d8:	b1 07       	cpc	r27, r17
      da:	d9 f7       	brne	.-10     	; 0xd2 <__do_copy_data+0xc>

000000dc <__do_clear_bss>:
      dc:	25 e0       	ldi	r18, 0x05	; 5
      de:	ac e3       	ldi	r26, 0x3C	; 60
      e0:	b1 e0       	ldi	r27, 0x01	; 1
      e2:	01 c0       	rjmp	.+2      	; 0xe6 <.do_clear_bss_start>

000000e4 <.do_clear_bss_loop>:
      e4:	1d 92       	st	X+, r1

000000e6 <.do_clear_bss_start>:
      e6:	a7 38       	cpi	r26, 0x87	; 135
      e8:	b2 07       	cpc	r27, r18
      ea:	e1 f7       	brne	.-8      	; 0xe4 <.do_clear_bss_loop>

000000ec <__do_global_ctors>:
      ec:	10 e0       	ldi	r17, 0x00	; 0
      ee:	cd e5       	ldi	r28, 0x5D	; 93
      f0:	d0 e0       	ldi	r29, 0x00	; 0
      f2:	04 c0       	rjmp	.+8      	; 0xfc <__do_global_ctors+0x10>
      f4:	21 97       	sbiw	r28, 0x01	; 1
      f6:	fe 01       	movw	r30, r28
      f8:	0e 94 74 09 	call	0x12e8	; 0x12e8 <__tablejump2__>
      fc:	cc 35       	cpi	r28, 0x5C	; 92
      fe:	d1 07       	cpc	r29, r17
     100:	c9 f7       	brne	.-14     	; 0xf4 <__do_global_ctors+0x8>
     102:	0e 94 d3 07 	call	0xfa6	; 0xfa6 <main>
     106:	0c 94 7a 09 	jmp	0x12f4	; 0x12f4 <_exit>

0000010a <__bad_interrupt>:
     10a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000010e <_Z8thread_2Pv>:
	}

}

void thread_2( void *pvParameters ){
	DDRB |= (1<<DDB0);
     10e:	20 9a       	sbi	0x04, 0	; 4
	while(1){
		PORTB ^= (1<<PORTB0);
     110:	c1 e0       	ldi	r28, 0x01	; 1
     112:	85 b1       	in	r24, 0x05	; 5
     114:	8c 27       	eor	r24, r28
     116:	85 b9       	out	0x05, r24	; 5
		vTaskDelay(2000);
     118:	80 ed       	ldi	r24, 0xD0	; 208
     11a:	97 e0       	ldi	r25, 0x07	; 7
     11c:	0e 94 ab 05 	call	0xb56	; 0xb56 <vTaskDelay>
		Serial.println("Hello World\r\n");
	}

}

void thread_2( void *pvParameters ){
     120:	f8 cf       	rjmp	.-16     	; 0x112 <_Z8thread_2Pv+0x4>

00000122 <_Z8thread_3Pv>:
		vTaskDelay(2000);
	}
}

void thread_3( void *pvParameters ){
	DDRB |= (1<<DDB1);
     122:	21 9a       	sbi	0x04, 1	; 4
	while(1){
		PORTB ^= (1<<PORTB1);
     124:	c2 e0       	ldi	r28, 0x02	; 2
     126:	85 b1       	in	r24, 0x05	; 5
     128:	8c 27       	eor	r24, r28
     12a:	85 b9       	out	0x05, r24	; 5
		vTaskDelay(200);
     12c:	88 ec       	ldi	r24, 0xC8	; 200
     12e:	90 e0       	ldi	r25, 0x00	; 0
     130:	0e 94 ab 05 	call	0xb56	; 0xb56 <vTaskDelay>
		PORTB ^= (1<<PORTB0);
		vTaskDelay(2000);
	}
}

void thread_3( void *pvParameters ){
     134:	f8 cf       	rjmp	.-16     	; 0x126 <_Z8thread_3Pv+0x4>

00000136 <_Z8thread_1Pv>:
  by Scott Fitzgerald
 */

void thread_1( void *pvParameters ){
	while(1){
		digitalWrite(13, HIGH);   // turn the LED on (HIGH is the voltage level)
     136:	61 e0       	ldi	r22, 0x01	; 1
     138:	8d e0       	ldi	r24, 0x0D	; 13
     13a:	0e 94 22 09 	call	0x1244	; 0x1244 <digitalWrite>
		vTaskDelay(500);              // wait for a second
     13e:	84 ef       	ldi	r24, 0xF4	; 244
     140:	91 e0       	ldi	r25, 0x01	; 1
     142:	0e 94 ab 05 	call	0xb56	; 0xb56 <vTaskDelay>
		digitalWrite(13, LOW);    // turn the LED off by making the voltage LOW
     146:	60 e0       	ldi	r22, 0x00	; 0
     148:	8d e0       	ldi	r24, 0x0D	; 13
     14a:	0e 94 22 09 	call	0x1244	; 0x1244 <digitalWrite>
		vTaskDelay(500);              // wait for a second
     14e:	84 ef       	ldi	r24, 0xF4	; 244
     150:	91 e0       	ldi	r25, 0x01	; 1
     152:	0e 94 ab 05 	call	0xb56	; 0xb56 <vTaskDelay>
		Serial.println("Hello World\r\n");
     156:	62 e0       	ldi	r22, 0x02	; 2
     158:	71 e0       	ldi	r23, 0x01	; 1
     15a:	81 ee       	ldi	r24, 0xE1	; 225
     15c:	94 e0       	ldi	r25, 0x04	; 4
     15e:	0e 94 26 08 	call	0x104c	; 0x104c <_ZN5Print7printlnEPKc>

  modified 8 May 2014
  by Scott Fitzgerald
 */

void thread_1( void *pvParameters ){
     162:	e9 cf       	rjmp	.-46     	; 0x136 <_Z8thread_1Pv>

00000164 <setup>:
}



// the setup function runs once when you press reset or power the board
void setup() {
     164:	af 92       	push	r10
     166:	bf 92       	push	r11
     168:	cf 92       	push	r12
     16a:	df 92       	push	r13
     16c:	ef 92       	push	r14
     16e:	ff 92       	push	r15
     170:	0f 93       	push	r16
  public:
    inline HardwareSerial(
      volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
      volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
      volatile uint8_t *ucsrc, volatile uint8_t *udr);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
     172:	26 e0       	ldi	r18, 0x06	; 6
     174:	40 e8       	ldi	r20, 0x80	; 128
     176:	55 e2       	ldi	r21, 0x25	; 37
     178:	60 e0       	ldi	r22, 0x00	; 0
     17a:	70 e0       	ldi	r23, 0x00	; 0
     17c:	81 ee       	ldi	r24, 0xE1	; 225
     17e:	94 e0       	ldi	r25, 0x04	; 4
     180:	0e 94 de 06 	call	0xdbc	; 0xdbc <_ZN14HardwareSerial5beginEmh>
	Serial.begin(9600);
  // initialize digital pin 13 as an output.
	pinMode(13, OUTPUT);
     184:	61 e0       	ldi	r22, 0x01	; 1
     186:	8d e0       	ldi	r24, 0x0D	; 13
     188:	0e 94 e6 08 	call	0x11cc	; 0x11cc <pinMode>
  
  	//creating the threads
	xTaskCreate( thread_1, ( const char * ) "t1", 300, NULL, tskIDLE_PRIORITY, NULL );
     18c:	a1 2c       	mov	r10, r1
     18e:	b1 2c       	mov	r11, r1
     190:	c1 2c       	mov	r12, r1
     192:	d1 2c       	mov	r13, r1
     194:	e1 2c       	mov	r14, r1
     196:	f1 2c       	mov	r15, r1
     198:	00 e0       	ldi	r16, 0x00	; 0
     19a:	20 e0       	ldi	r18, 0x00	; 0
     19c:	30 e0       	ldi	r19, 0x00	; 0
     19e:	4c e2       	ldi	r20, 0x2C	; 44
     1a0:	51 e0       	ldi	r21, 0x01	; 1
     1a2:	60 e1       	ldi	r22, 0x10	; 16
     1a4:	71 e0       	ldi	r23, 0x01	; 1
     1a6:	8b e9       	ldi	r24, 0x9B	; 155
     1a8:	90 e0       	ldi	r25, 0x00	; 0
     1aa:	0e 94 4d 03 	call	0x69a	; 0x69a <xTaskGenericCreate>
	xTaskCreate( thread_2, ( const char * ) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
     1ae:	20 e0       	ldi	r18, 0x00	; 0
     1b0:	30 e0       	ldi	r19, 0x00	; 0
     1b2:	44 e6       	ldi	r20, 0x64	; 100
     1b4:	50 e0       	ldi	r21, 0x00	; 0
     1b6:	63 e1       	ldi	r22, 0x13	; 19
     1b8:	71 e0       	ldi	r23, 0x01	; 1
     1ba:	87 e8       	ldi	r24, 0x87	; 135
     1bc:	90 e0       	ldi	r25, 0x00	; 0
     1be:	0e 94 4d 03 	call	0x69a	; 0x69a <xTaskGenericCreate>
	xTaskCreate( thread_3, ( const char * ) "t3", 100, NULL, tskIDLE_PRIORITY, NULL );
     1c2:	20 e0       	ldi	r18, 0x00	; 0
     1c4:	30 e0       	ldi	r19, 0x00	; 0
     1c6:	44 e6       	ldi	r20, 0x64	; 100
     1c8:	50 e0       	ldi	r21, 0x00	; 0
     1ca:	66 e1       	ldi	r22, 0x16	; 22
     1cc:	71 e0       	ldi	r23, 0x01	; 1
     1ce:	81 e9       	ldi	r24, 0x91	; 145
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	0e 94 4d 03 	call	0x69a	; 0x69a <xTaskGenericCreate>
  
	//starting the scheduler
	vTaskStartScheduler();
}
     1d6:	0f 91       	pop	r16
     1d8:	ff 90       	pop	r15
     1da:	ef 90       	pop	r14
     1dc:	df 90       	pop	r13
     1de:	cf 90       	pop	r12
     1e0:	bf 90       	pop	r11
     1e2:	af 90       	pop	r10
	xTaskCreate( thread_1, ( const char * ) "t1", 300, NULL, tskIDLE_PRIORITY, NULL );
	xTaskCreate( thread_2, ( const char * ) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
	xTaskCreate( thread_3, ( const char * ) "t3", 100, NULL, tskIDLE_PRIORITY, NULL );
  
	//starting the scheduler
	vTaskStartScheduler();
     1e4:	0c 94 3c 04 	jmp	0x878	; 0x878 <vTaskStartScheduler>

000001e8 <loop>:
}

// the loop function runs over and over again forever
void loop() {
     1e8:	08 95       	ret

000001ea <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     1ea:	31 e1       	ldi	r19, 0x11	; 17
     1ec:	fc 01       	movw	r30, r24
     1ee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     1f0:	31 97       	sbiw	r30, 0x01	; 1
     1f2:	22 e2       	ldi	r18, 0x22	; 34
     1f4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     1f6:	31 97       	sbiw	r30, 0x01	; 1
     1f8:	a3 e3       	ldi	r26, 0x33	; 51
     1fa:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     1fc:	31 97       	sbiw	r30, 0x01	; 1
     1fe:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     200:	31 97       	sbiw	r30, 0x01	; 1
     202:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     204:	31 97       	sbiw	r30, 0x01	; 1
     206:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     208:	31 97       	sbiw	r30, 0x01	; 1
     20a:	60 e8       	ldi	r22, 0x80	; 128
     20c:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     20e:	31 97       	sbiw	r30, 0x01	; 1
     210:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     212:	31 97       	sbiw	r30, 0x01	; 1
     214:	62 e0       	ldi	r22, 0x02	; 2
     216:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     218:	31 97       	sbiw	r30, 0x01	; 1
     21a:	63 e0       	ldi	r22, 0x03	; 3
     21c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     21e:	31 97       	sbiw	r30, 0x01	; 1
     220:	64 e0       	ldi	r22, 0x04	; 4
     222:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     224:	31 97       	sbiw	r30, 0x01	; 1
     226:	65 e0       	ldi	r22, 0x05	; 5
     228:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     22a:	31 97       	sbiw	r30, 0x01	; 1
     22c:	66 e0       	ldi	r22, 0x06	; 6
     22e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     230:	31 97       	sbiw	r30, 0x01	; 1
     232:	67 e0       	ldi	r22, 0x07	; 7
     234:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     236:	31 97       	sbiw	r30, 0x01	; 1
     238:	68 e0       	ldi	r22, 0x08	; 8
     23a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     23c:	31 97       	sbiw	r30, 0x01	; 1
     23e:	69 e0       	ldi	r22, 0x09	; 9
     240:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     242:	31 97       	sbiw	r30, 0x01	; 1
     244:	60 e1       	ldi	r22, 0x10	; 16
     246:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     248:	31 97       	sbiw	r30, 0x01	; 1
     24a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	32 e1       	ldi	r19, 0x12	; 18
     250:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     252:	31 97       	sbiw	r30, 0x01	; 1
     254:	33 e1       	ldi	r19, 0x13	; 19
     256:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     258:	31 97       	sbiw	r30, 0x01	; 1
     25a:	34 e1       	ldi	r19, 0x14	; 20
     25c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	35 e1       	ldi	r19, 0x15	; 21
     262:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     264:	31 97       	sbiw	r30, 0x01	; 1
     266:	36 e1       	ldi	r19, 0x16	; 22
     268:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     26a:	31 97       	sbiw	r30, 0x01	; 1
     26c:	37 e1       	ldi	r19, 0x17	; 23
     26e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     270:	31 97       	sbiw	r30, 0x01	; 1
     272:	38 e1       	ldi	r19, 0x18	; 24
     274:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     276:	31 97       	sbiw	r30, 0x01	; 1
     278:	39 e1       	ldi	r19, 0x19	; 25
     27a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     27c:	31 97       	sbiw	r30, 0x01	; 1
     27e:	30 e2       	ldi	r19, 0x20	; 32
     280:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     282:	31 97       	sbiw	r30, 0x01	; 1
     284:	31 e2       	ldi	r19, 0x21	; 33
     286:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     288:	31 97       	sbiw	r30, 0x01	; 1
     28a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     28c:	31 97       	sbiw	r30, 0x01	; 1
     28e:	23 e2       	ldi	r18, 0x23	; 35
     290:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     292:	31 97       	sbiw	r30, 0x01	; 1
     294:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     296:	31 97       	sbiw	r30, 0x01	; 1
     298:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     29a:	31 97       	sbiw	r30, 0x01	; 1
     29c:	26 e2       	ldi	r18, 0x26	; 38
     29e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     2a0:	31 97       	sbiw	r30, 0x01	; 1
     2a2:	27 e2       	ldi	r18, 0x27	; 39
     2a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     2a6:	31 97       	sbiw	r30, 0x01	; 1
     2a8:	28 e2       	ldi	r18, 0x28	; 40
     2aa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     2ac:	31 97       	sbiw	r30, 0x01	; 1
     2ae:	29 e2       	ldi	r18, 0x29	; 41
     2b0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     2b2:	31 97       	sbiw	r30, 0x01	; 1
     2b4:	20 e3       	ldi	r18, 0x30	; 48
     2b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     2b8:	31 97       	sbiw	r30, 0x01	; 1
     2ba:	21 e3       	ldi	r18, 0x31	; 49
     2bc:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     2be:	86 97       	sbiw	r24, 0x26	; 38
     2c0:	08 95       	ret

000002c2 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     2c2:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     2c6:	8c e7       	ldi	r24, 0x7C	; 124
     2c8:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     2cc:	8b e0       	ldi	r24, 0x0B	; 11
     2ce:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     2d2:	ef e6       	ldi	r30, 0x6F	; 111
     2d4:	f0 e0       	ldi	r31, 0x00	; 0
     2d6:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     2d8:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     2da:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     2dc:	a0 91 df 04 	lds	r26, 0x04DF
     2e0:	b0 91 e0 04 	lds	r27, 0x04E0
     2e4:	cd 91       	ld	r28, X+
     2e6:	cd bf       	out	0x3d, r28	; 61
     2e8:	dd 91       	ld	r29, X+
     2ea:	de bf       	out	0x3e, r29	; 62
     2ec:	ff 91       	pop	r31
     2ee:	ef 91       	pop	r30
     2f0:	df 91       	pop	r29
     2f2:	cf 91       	pop	r28
     2f4:	bf 91       	pop	r27
     2f6:	af 91       	pop	r26
     2f8:	9f 91       	pop	r25
     2fa:	8f 91       	pop	r24
     2fc:	7f 91       	pop	r23
     2fe:	6f 91       	pop	r22
     300:	5f 91       	pop	r21
     302:	4f 91       	pop	r20
     304:	3f 91       	pop	r19
     306:	2f 91       	pop	r18
     308:	1f 91       	pop	r17
     30a:	0f 91       	pop	r16
     30c:	ff 90       	pop	r15
     30e:	ef 90       	pop	r14
     310:	df 90       	pop	r13
     312:	cf 90       	pop	r12
     314:	bf 90       	pop	r11
     316:	af 90       	pop	r10
     318:	9f 90       	pop	r9
     31a:	8f 90       	pop	r8
     31c:	7f 90       	pop	r7
     31e:	6f 90       	pop	r6
     320:	5f 90       	pop	r5
     322:	4f 90       	pop	r4
     324:	3f 90       	pop	r3
     326:	2f 90       	pop	r2
     328:	1f 90       	pop	r1
     32a:	0f 90       	pop	r0
     32c:	0f be       	out	0x3f, r0	; 63
     32e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     330:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     332:	81 e0       	ldi	r24, 0x01	; 1
     334:	08 95       	ret

00000336 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     336:	0f 92       	push	r0
     338:	0f b6       	in	r0, 0x3f	; 63
     33a:	f8 94       	cli
     33c:	0f 92       	push	r0
     33e:	1f 92       	push	r1
     340:	11 24       	eor	r1, r1
     342:	2f 92       	push	r2
     344:	3f 92       	push	r3
     346:	4f 92       	push	r4
     348:	5f 92       	push	r5
     34a:	6f 92       	push	r6
     34c:	7f 92       	push	r7
     34e:	8f 92       	push	r8
     350:	9f 92       	push	r9
     352:	af 92       	push	r10
     354:	bf 92       	push	r11
     356:	cf 92       	push	r12
     358:	df 92       	push	r13
     35a:	ef 92       	push	r14
     35c:	ff 92       	push	r15
     35e:	0f 93       	push	r16
     360:	1f 93       	push	r17
     362:	2f 93       	push	r18
     364:	3f 93       	push	r19
     366:	4f 93       	push	r20
     368:	5f 93       	push	r21
     36a:	6f 93       	push	r22
     36c:	7f 93       	push	r23
     36e:	8f 93       	push	r24
     370:	9f 93       	push	r25
     372:	af 93       	push	r26
     374:	bf 93       	push	r27
     376:	cf 93       	push	r28
     378:	df 93       	push	r29
     37a:	ef 93       	push	r30
     37c:	ff 93       	push	r31
     37e:	a0 91 df 04 	lds	r26, 0x04DF
     382:	b0 91 e0 04 	lds	r27, 0x04E0
     386:	0d b6       	in	r0, 0x3d	; 61
     388:	0d 92       	st	X+, r0
     38a:	0e b6       	in	r0, 0x3e	; 62
     38c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     38e:	0e 94 cc 05 	call	0xb98	; 0xb98 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     392:	a0 91 df 04 	lds	r26, 0x04DF
     396:	b0 91 e0 04 	lds	r27, 0x04E0
     39a:	cd 91       	ld	r28, X+
     39c:	cd bf       	out	0x3d, r28	; 61
     39e:	dd 91       	ld	r29, X+
     3a0:	de bf       	out	0x3e, r29	; 62
     3a2:	ff 91       	pop	r31
     3a4:	ef 91       	pop	r30
     3a6:	df 91       	pop	r29
     3a8:	cf 91       	pop	r28
     3aa:	bf 91       	pop	r27
     3ac:	af 91       	pop	r26
     3ae:	9f 91       	pop	r25
     3b0:	8f 91       	pop	r24
     3b2:	7f 91       	pop	r23
     3b4:	6f 91       	pop	r22
     3b6:	5f 91       	pop	r21
     3b8:	4f 91       	pop	r20
     3ba:	3f 91       	pop	r19
     3bc:	2f 91       	pop	r18
     3be:	1f 91       	pop	r17
     3c0:	0f 91       	pop	r16
     3c2:	ff 90       	pop	r15
     3c4:	ef 90       	pop	r14
     3c6:	df 90       	pop	r13
     3c8:	cf 90       	pop	r12
     3ca:	bf 90       	pop	r11
     3cc:	af 90       	pop	r10
     3ce:	9f 90       	pop	r9
     3d0:	8f 90       	pop	r8
     3d2:	7f 90       	pop	r7
     3d4:	6f 90       	pop	r6
     3d6:	5f 90       	pop	r5
     3d8:	4f 90       	pop	r4
     3da:	3f 90       	pop	r3
     3dc:	2f 90       	pop	r2
     3de:	1f 90       	pop	r1
     3e0:	0f 90       	pop	r0
     3e2:	0f be       	out	0x3f, r0	; 63
     3e4:	0f 90       	pop	r0

	asm volatile ( "ret" );
     3e6:	08 95       	ret

000003e8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     3e8:	0f 92       	push	r0
     3ea:	0f b6       	in	r0, 0x3f	; 63
     3ec:	f8 94       	cli
     3ee:	0f 92       	push	r0
     3f0:	1f 92       	push	r1
     3f2:	11 24       	eor	r1, r1
     3f4:	2f 92       	push	r2
     3f6:	3f 92       	push	r3
     3f8:	4f 92       	push	r4
     3fa:	5f 92       	push	r5
     3fc:	6f 92       	push	r6
     3fe:	7f 92       	push	r7
     400:	8f 92       	push	r8
     402:	9f 92       	push	r9
     404:	af 92       	push	r10
     406:	bf 92       	push	r11
     408:	cf 92       	push	r12
     40a:	df 92       	push	r13
     40c:	ef 92       	push	r14
     40e:	ff 92       	push	r15
     410:	0f 93       	push	r16
     412:	1f 93       	push	r17
     414:	2f 93       	push	r18
     416:	3f 93       	push	r19
     418:	4f 93       	push	r20
     41a:	5f 93       	push	r21
     41c:	6f 93       	push	r22
     41e:	7f 93       	push	r23
     420:	8f 93       	push	r24
     422:	9f 93       	push	r25
     424:	af 93       	push	r26
     426:	bf 93       	push	r27
     428:	cf 93       	push	r28
     42a:	df 93       	push	r29
     42c:	ef 93       	push	r30
     42e:	ff 93       	push	r31
     430:	a0 91 df 04 	lds	r26, 0x04DF
     434:	b0 91 e0 04 	lds	r27, 0x04E0
     438:	0d b6       	in	r0, 0x3d	; 61
     43a:	0d 92       	st	X+, r0
     43c:	0e b6       	in	r0, 0x3e	; 62
     43e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     440:	0e 94 74 04 	call	0x8e8	; 0x8e8 <xTaskIncrementTick>
     444:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     446:	0e 94 cc 05 	call	0xb98	; 0xb98 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     44a:	a0 91 df 04 	lds	r26, 0x04DF
     44e:	b0 91 e0 04 	lds	r27, 0x04E0
     452:	cd 91       	ld	r28, X+
     454:	cd bf       	out	0x3d, r28	; 61
     456:	dd 91       	ld	r29, X+
     458:	de bf       	out	0x3e, r29	; 62
     45a:	ff 91       	pop	r31
     45c:	ef 91       	pop	r30
     45e:	df 91       	pop	r29
     460:	cf 91       	pop	r28
     462:	bf 91       	pop	r27
     464:	af 91       	pop	r26
     466:	9f 91       	pop	r25
     468:	8f 91       	pop	r24
     46a:	7f 91       	pop	r23
     46c:	6f 91       	pop	r22
     46e:	5f 91       	pop	r21
     470:	4f 91       	pop	r20
     472:	3f 91       	pop	r19
     474:	2f 91       	pop	r18
     476:	1f 91       	pop	r17
     478:	0f 91       	pop	r16
     47a:	ff 90       	pop	r15
     47c:	ef 90       	pop	r14
     47e:	df 90       	pop	r13
     480:	cf 90       	pop	r12
     482:	bf 90       	pop	r11
     484:	af 90       	pop	r10
     486:	9f 90       	pop	r9
     488:	8f 90       	pop	r8
     48a:	7f 90       	pop	r7
     48c:	6f 90       	pop	r6
     48e:	5f 90       	pop	r5
     490:	4f 90       	pop	r4
     492:	3f 90       	pop	r3
     494:	2f 90       	pop	r2
     496:	1f 90       	pop	r1
     498:	0f 90       	pop	r0
     49a:	0f be       	out	0x3f, r0	; 63
     49c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     49e:	08 95       	ret

000004a0 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     4a0:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <vPortYieldFromTick>
		asm volatile ( "reti" );
     4a4:	18 95       	reti

000004a6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     4a6:	cf 93       	push	r28
     4a8:	df 93       	push	r29
     4aa:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     4ac:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     4b0:	80 91 3c 01 	lds	r24, 0x013C
     4b4:	90 91 3d 01 	lds	r25, 0x013D
     4b8:	89 2b       	or	r24, r25
     4ba:	31 f4       	brne	.+12     	; 0x4c8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     4bc:	81 e4       	ldi	r24, 0x41	; 65
     4be:	91 e0       	ldi	r25, 0x01	; 1
     4c0:	90 93 3d 01 	sts	0x013D, r25
     4c4:	80 93 3c 01 	sts	0x013C, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     4c8:	20 91 3e 01 	lds	r18, 0x013E
     4cc:	30 91 3f 01 	lds	r19, 0x013F
     4d0:	ce 01       	movw	r24, r28
     4d2:	82 0f       	add	r24, r18
     4d4:	93 1f       	adc	r25, r19
     4d6:	81 35       	cpi	r24, 0x51	; 81
     4d8:	43 e0       	ldi	r20, 0x03	; 3
     4da:	94 07       	cpc	r25, r20
     4dc:	70 f4       	brcc	.+28     	; 0x4fa <pvPortMalloc+0x54>
     4de:	28 17       	cp	r18, r24
     4e0:	39 07       	cpc	r19, r25
     4e2:	58 f4       	brcc	.+22     	; 0x4fa <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     4e4:	c0 91 3c 01 	lds	r28, 0x013C
     4e8:	d0 91 3d 01 	lds	r29, 0x013D
     4ec:	c2 0f       	add	r28, r18
     4ee:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     4f0:	90 93 3f 01 	sts	0x013F, r25
     4f4:	80 93 3e 01 	sts	0x013E, r24
     4f8:	02 c0       	rjmp	.+4      	; 0x4fe <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     4fa:	c0 e0       	ldi	r28, 0x00	; 0
     4fc:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     4fe:	0e 94 3b 05 	call	0xa76	; 0xa76 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     502:	ce 01       	movw	r24, r28
     504:	df 91       	pop	r29
     506:	cf 91       	pop	r28
     508:	08 95       	ret

0000050a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     50a:	08 95       	ret

0000050c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     50c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     50e:	03 96       	adiw	r24, 0x03	; 3
     510:	92 83       	std	Z+2, r25	; 0x02
     512:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     514:	2f ef       	ldi	r18, 0xFF	; 255
     516:	3f ef       	ldi	r19, 0xFF	; 255
     518:	34 83       	std	Z+4, r19	; 0x04
     51a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     51c:	96 83       	std	Z+6, r25	; 0x06
     51e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     520:	90 87       	std	Z+8, r25	; 0x08
     522:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     524:	10 82       	st	Z, r1
     526:	08 95       	ret

00000528 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     528:	fc 01       	movw	r30, r24
     52a:	11 86       	std	Z+9, r1	; 0x09
     52c:	10 86       	std	Z+8, r1	; 0x08
     52e:	08 95       	ret

00000530 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     530:	cf 93       	push	r28
     532:	df 93       	push	r29
     534:	9c 01       	movw	r18, r24
     536:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     538:	dc 01       	movw	r26, r24
     53a:	11 96       	adiw	r26, 0x01	; 1
     53c:	cd 91       	ld	r28, X+
     53e:	dc 91       	ld	r29, X
     540:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     542:	d3 83       	std	Z+3, r29	; 0x03
     544:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     546:	8c 81       	ldd	r24, Y+4	; 0x04
     548:	9d 81       	ldd	r25, Y+5	; 0x05
     54a:	95 83       	std	Z+5, r25	; 0x05
     54c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
     54e:	8c 81       	ldd	r24, Y+4	; 0x04
     550:	9d 81       	ldd	r25, Y+5	; 0x05
     552:	dc 01       	movw	r26, r24
     554:	13 96       	adiw	r26, 0x03	; 3
     556:	7c 93       	st	X, r23
     558:	6e 93       	st	-X, r22
     55a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     55c:	7d 83       	std	Y+5, r23	; 0x05
     55e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     560:	31 87       	std	Z+9, r19	; 0x09
     562:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     564:	f9 01       	movw	r30, r18
     566:	80 81       	ld	r24, Z
     568:	8f 5f       	subi	r24, 0xFF	; 255
     56a:	80 83       	st	Z, r24
}
     56c:	df 91       	pop	r29
     56e:	cf 91       	pop	r28
     570:	08 95       	ret

00000572 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     572:	0f 93       	push	r16
     574:	1f 93       	push	r17
     576:	cf 93       	push	r28
     578:	df 93       	push	r29
     57a:	8c 01       	movw	r16, r24
     57c:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     57e:	80 81       	ld	r24, Z
     580:	91 81       	ldd	r25, Z+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     582:	8f 3f       	cpi	r24, 0xFF	; 255
     584:	2f ef       	ldi	r18, 0xFF	; 255
     586:	92 07       	cpc	r25, r18
     588:	21 f4       	brne	.+8      	; 0x592 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     58a:	e8 01       	movw	r28, r16
     58c:	af 81       	ldd	r26, Y+7	; 0x07
     58e:	b8 85       	ldd	r27, Y+8	; 0x08
     590:	0e c0       	rjmp	.+28     	; 0x5ae <vListInsert+0x3c>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     592:	d8 01       	movw	r26, r16
     594:	13 96       	adiw	r26, 0x03	; 3
     596:	12 96       	adiw	r26, 0x02	; 2
     598:	2d 91       	ld	r18, X+
     59a:	3c 91       	ld	r19, X
     59c:	13 97       	sbiw	r26, 0x03	; 3
     59e:	e9 01       	movw	r28, r18
     5a0:	48 81       	ld	r20, Y
     5a2:	59 81       	ldd	r21, Y+1	; 0x01
     5a4:	84 17       	cp	r24, r20
     5a6:	95 07       	cpc	r25, r21
     5a8:	10 f0       	brcs	.+4      	; 0x5ae <vListInsert+0x3c>
     5aa:	d9 01       	movw	r26, r18
     5ac:	f4 cf       	rjmp	.-24     	; 0x596 <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     5ae:	12 96       	adiw	r26, 0x02	; 2
     5b0:	8d 91       	ld	r24, X+
     5b2:	9c 91       	ld	r25, X
     5b4:	13 97       	sbiw	r26, 0x03	; 3
     5b6:	93 83       	std	Z+3, r25	; 0x03
     5b8:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     5ba:	ec 01       	movw	r28, r24
     5bc:	fd 83       	std	Y+5, r31	; 0x05
     5be:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     5c0:	b5 83       	std	Z+5, r27	; 0x05
     5c2:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     5c4:	13 96       	adiw	r26, 0x03	; 3
     5c6:	fc 93       	st	X, r31
     5c8:	ee 93       	st	-X, r30
     5ca:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     5cc:	11 87       	std	Z+9, r17	; 0x09
     5ce:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
     5d0:	f8 01       	movw	r30, r16
     5d2:	80 81       	ld	r24, Z
     5d4:	8f 5f       	subi	r24, 0xFF	; 255
     5d6:	80 83       	st	Z, r24
}
     5d8:	df 91       	pop	r29
     5da:	cf 91       	pop	r28
     5dc:	1f 91       	pop	r17
     5de:	0f 91       	pop	r16
     5e0:	08 95       	ret

000005e2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     5e2:	cf 93       	push	r28
     5e4:	df 93       	push	r29
     5e6:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     5e8:	a0 85       	ldd	r26, Z+8	; 0x08
     5ea:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     5ec:	82 81       	ldd	r24, Z+2	; 0x02
     5ee:	93 81       	ldd	r25, Z+3	; 0x03
     5f0:	24 81       	ldd	r18, Z+4	; 0x04
     5f2:	35 81       	ldd	r19, Z+5	; 0x05
     5f4:	ec 01       	movw	r28, r24
     5f6:	3d 83       	std	Y+5, r19	; 0x05
     5f8:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     5fa:	c4 81       	ldd	r28, Z+4	; 0x04
     5fc:	d5 81       	ldd	r29, Z+5	; 0x05
     5fe:	9b 83       	std	Y+3, r25	; 0x03
     600:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     602:	11 96       	adiw	r26, 0x01	; 1
     604:	8d 91       	ld	r24, X+
     606:	9c 91       	ld	r25, X
     608:	12 97       	sbiw	r26, 0x02	; 2
     60a:	8e 17       	cp	r24, r30
     60c:	9f 07       	cpc	r25, r31
     60e:	21 f4       	brne	.+8      	; 0x618 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     610:	12 96       	adiw	r26, 0x02	; 2
     612:	dc 93       	st	X, r29
     614:	ce 93       	st	-X, r28
     616:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     618:	11 86       	std	Z+9, r1	; 0x09
     61a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     61c:	8c 91       	ld	r24, X
     61e:	81 50       	subi	r24, 0x01	; 1
     620:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     622:	df 91       	pop	r29
     624:	cf 91       	pop	r28
     626:	08 95       	ret

00000628 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
     628:	ff cf       	rjmp	.-2      	; 0x628 <prvIdleTask>

0000062a <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     62a:	cf 93       	push	r28
     62c:	df 93       	push	r29
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     62e:	e0 91 df 04 	lds	r30, 0x04DF
     632:	f0 91 e0 04 	lds	r31, 0x04E0
     636:	93 83       	std	Z+3, r25	; 0x03
     638:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     63a:	20 91 99 04 	lds	r18, 0x0499
     63e:	30 91 9a 04 	lds	r19, 0x049A
     642:	82 17       	cp	r24, r18
     644:	93 07       	cpc	r25, r19
     646:	70 f4       	brcc	.+28     	; 0x664 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     648:	60 91 df 04 	lds	r22, 0x04DF
     64c:	70 91 e0 04 	lds	r23, 0x04E0
     650:	80 91 a5 04 	lds	r24, 0x04A5
     654:	90 91 a6 04 	lds	r25, 0x04A6
     658:	6e 5f       	subi	r22, 0xFE	; 254
     65a:	7f 4f       	sbci	r23, 0xFF	; 255
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     65c:	df 91       	pop	r29
     65e:	cf 91       	pop	r28
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     660:	0c 94 b9 02 	jmp	0x572	; 0x572 <vListInsert>
     664:	ec 01       	movw	r28, r24
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     666:	60 91 df 04 	lds	r22, 0x04DF
     66a:	70 91 e0 04 	lds	r23, 0x04E0
     66e:	80 91 a7 04 	lds	r24, 0x04A7
     672:	90 91 a8 04 	lds	r25, 0x04A8
     676:	6e 5f       	subi	r22, 0xFE	; 254
     678:	7f 4f       	sbci	r23, 0xFF	; 255
     67a:	0e 94 b9 02 	call	0x572	; 0x572 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     67e:	80 91 00 01 	lds	r24, 0x0100
     682:	90 91 01 01 	lds	r25, 0x0101
     686:	c8 17       	cp	r28, r24
     688:	d9 07       	cpc	r29, r25
     68a:	20 f4       	brcc	.+8      	; 0x694 <prvAddCurrentTaskToDelayedList+0x6a>
		{
			xNextTaskUnblockTime = xTimeToWake;
     68c:	d0 93 01 01 	sts	0x0101, r29
     690:	c0 93 00 01 	sts	0x0100, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     694:	df 91       	pop	r29
     696:	cf 91       	pop	r28
     698:	08 95       	ret

0000069a <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     69a:	5f 92       	push	r5
     69c:	6f 92       	push	r6
     69e:	7f 92       	push	r7
     6a0:	8f 92       	push	r8
     6a2:	9f 92       	push	r9
     6a4:	af 92       	push	r10
     6a6:	bf 92       	push	r11
     6a8:	cf 92       	push	r12
     6aa:	df 92       	push	r13
     6ac:	ef 92       	push	r14
     6ae:	ff 92       	push	r15
     6b0:	0f 93       	push	r16
     6b2:	1f 93       	push	r17
     6b4:	cf 93       	push	r28
     6b6:	df 93       	push	r29
     6b8:	4c 01       	movw	r8, r24
     6ba:	16 2f       	mov	r17, r22
     6bc:	57 2e       	mov	r5, r23
     6be:	5a 01       	movw	r10, r20
     6c0:	39 01       	movw	r6, r18
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     6c2:	81 e2       	ldi	r24, 0x21	; 33
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	0e 94 53 02 	call	0x4a6	; 0x4a6 <pvPortMalloc>
     6ca:	ec 01       	movw	r28, r24

	if( pxNewTCB != NULL )
     6cc:	89 2b       	or	r24, r25
     6ce:	79 f0       	breq	.+30     	; 0x6ee <xTaskGenericCreate+0x54>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     6d0:	c1 14       	cp	r12, r1
     6d2:	d1 04       	cpc	r13, r1
     6d4:	21 f4       	brne	.+8      	; 0x6de <xTaskGenericCreate+0x44>
     6d6:	c5 01       	movw	r24, r10
     6d8:	0e 94 53 02 	call	0x4a6	; 0x4a6 <pvPortMalloc>
     6dc:	01 c0       	rjmp	.+2      	; 0x6e0 <xTaskGenericCreate+0x46>
     6de:	c6 01       	movw	r24, r12
     6e0:	98 8f       	std	Y+24, r25	; 0x18
     6e2:	8f 8b       	std	Y+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
     6e4:	00 97       	sbiw	r24, 0x00	; 0
     6e6:	29 f4       	brne	.+10     	; 0x6f2 <xTaskGenericCreate+0x58>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
     6e8:	ce 01       	movw	r24, r28
     6ea:	0e 94 85 02 	call	0x50a	; 0x50a <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     6ee:	8f ef       	ldi	r24, 0xFF	; 255
     6f0:	b3 c0       	rjmp	.+358    	; 0x858 <xTaskGenericCreate+0x1be>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     6f2:	21 e0       	ldi	r18, 0x01	; 1
     6f4:	a2 1a       	sub	r10, r18
     6f6:	b1 08       	sbc	r11, r1
     6f8:	a8 0e       	add	r10, r24
     6fa:	b9 1e       	adc	r11, r25
     6fc:	be 01       	movw	r22, r28
     6fe:	67 5e       	subi	r22, 0xE7	; 231
     700:	7f 4f       	sbci	r23, 0xFF	; 255
     702:	e1 2f       	mov	r30, r17
     704:	f5 2d       	mov	r31, r5
     706:	cf 01       	movw	r24, r30
     708:	08 96       	adiw	r24, 0x08	; 8
     70a:	9f 01       	movw	r18, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     70c:	41 91       	ld	r20, Z+
     70e:	db 01       	movw	r26, r22
     710:	4d 93       	st	X+, r20
     712:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     714:	d9 01       	movw	r26, r18
     716:	2c 91       	ld	r18, X
     718:	22 23       	and	r18, r18
     71a:	19 f0       	breq	.+6      	; 0x722 <xTaskGenericCreate+0x88>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     71c:	e8 17       	cp	r30, r24
     71e:	f9 07       	cpc	r31, r25
     720:	a1 f7       	brne	.-24     	; 0x70a <xTaskGenericCreate+0x70>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     722:	18 a2       	std	Y+32, r1	; 0x20
     724:	10 2f       	mov	r17, r16
     726:	04 30       	cpi	r16, 0x04	; 4
     728:	08 f0       	brcs	.+2      	; 0x72c <xTaskGenericCreate+0x92>
     72a:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     72c:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     72e:	6e 01       	movw	r12, r28
     730:	b2 e0       	ldi	r27, 0x02	; 2
     732:	cb 0e       	add	r12, r27
     734:	d1 1c       	adc	r13, r1
     736:	c6 01       	movw	r24, r12
     738:	0e 94 94 02 	call	0x528	; 0x528 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     73c:	ce 01       	movw	r24, r28
     73e:	0c 96       	adiw	r24, 0x0c	; 12
     740:	0e 94 94 02 	call	0x528	; 0x528 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     744:	d9 87       	std	Y+9, r29	; 0x09
     746:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     748:	84 e0       	ldi	r24, 0x04	; 4
     74a:	90 e0       	ldi	r25, 0x00	; 0
     74c:	81 1b       	sub	r24, r17
     74e:	91 09       	sbc	r25, r1
     750:	9d 87       	std	Y+13, r25	; 0x0d
     752:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     754:	db 8b       	std	Y+19, r29	; 0x13
     756:	ca 8b       	std	Y+18, r28	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     758:	a3 01       	movw	r20, r6
     75a:	b4 01       	movw	r22, r8
     75c:	c5 01       	movw	r24, r10
     75e:	0e 94 f5 00 	call	0x1ea	; 0x1ea <pxPortInitialiseStack>
     762:	99 83       	std	Y+1, r25	; 0x01
     764:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     766:	e1 14       	cp	r14, r1
     768:	f1 04       	cpc	r15, r1
     76a:	19 f0       	breq	.+6      	; 0x772 <xTaskGenericCreate+0xd8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     76c:	f7 01       	movw	r30, r14
     76e:	d1 83       	std	Z+1, r29	; 0x01
     770:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     772:	0f b6       	in	r0, 0x3f	; 63
     774:	f8 94       	cli
     776:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     778:	80 91 9b 04 	lds	r24, 0x049B
     77c:	8f 5f       	subi	r24, 0xFF	; 255
     77e:	80 93 9b 04 	sts	0x049B, r24
			if( pxCurrentTCB == NULL )
     782:	80 91 df 04 	lds	r24, 0x04DF
     786:	90 91 e0 04 	lds	r25, 0x04E0
     78a:	89 2b       	or	r24, r25
     78c:	89 f5       	brne	.+98     	; 0x7f0 <xTaskGenericCreate+0x156>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     78e:	d0 93 e0 04 	sts	0x04E0, r29
     792:	c0 93 df 04 	sts	0x04DF, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     796:	80 91 9b 04 	lds	r24, 0x049B
     79a:	81 30       	cpi	r24, 0x01	; 1
     79c:	c1 f5       	brne	.+112    	; 0x80e <xTaskGenericCreate+0x174>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     79e:	8b eb       	ldi	r24, 0xBB	; 187
     7a0:	94 e0       	ldi	r25, 0x04	; 4
     7a2:	0e 94 86 02 	call	0x50c	; 0x50c <vListInitialise>
     7a6:	84 ec       	ldi	r24, 0xC4	; 196
     7a8:	94 e0       	ldi	r25, 0x04	; 4
     7aa:	0e 94 86 02 	call	0x50c	; 0x50c <vListInitialise>
     7ae:	8d ec       	ldi	r24, 0xCD	; 205
     7b0:	94 e0       	ldi	r25, 0x04	; 4
     7b2:	0e 94 86 02 	call	0x50c	; 0x50c <vListInitialise>
     7b6:	86 ed       	ldi	r24, 0xD6	; 214
     7b8:	94 e0       	ldi	r25, 0x04	; 4
     7ba:	0e 94 86 02 	call	0x50c	; 0x50c <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     7be:	82 eb       	ldi	r24, 0xB2	; 178
     7c0:	94 e0       	ldi	r25, 0x04	; 4
     7c2:	0e 94 86 02 	call	0x50c	; 0x50c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     7c6:	89 ea       	ldi	r24, 0xA9	; 169
     7c8:	94 e0       	ldi	r25, 0x04	; 4
     7ca:	0e 94 86 02 	call	0x50c	; 0x50c <vListInitialise>
	vListInitialise( &xPendingReadyList );
     7ce:	8c e9       	ldi	r24, 0x9C	; 156
     7d0:	94 e0       	ldi	r25, 0x04	; 4
     7d2:	0e 94 86 02 	call	0x50c	; 0x50c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     7d6:	82 eb       	ldi	r24, 0xB2	; 178
     7d8:	94 e0       	ldi	r25, 0x04	; 4
     7da:	90 93 a8 04 	sts	0x04A8, r25
     7de:	80 93 a7 04 	sts	0x04A7, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     7e2:	89 ea       	ldi	r24, 0xA9	; 169
     7e4:	94 e0       	ldi	r25, 0x04	; 4
     7e6:	90 93 a6 04 	sts	0x04A6, r25
     7ea:	80 93 a5 04 	sts	0x04A5, r24
     7ee:	0f c0       	rjmp	.+30     	; 0x80e <xTaskGenericCreate+0x174>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     7f0:	80 91 97 04 	lds	r24, 0x0497
     7f4:	81 11       	cpse	r24, r1
     7f6:	0b c0       	rjmp	.+22     	; 0x80e <xTaskGenericCreate+0x174>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     7f8:	e0 91 df 04 	lds	r30, 0x04DF
     7fc:	f0 91 e0 04 	lds	r31, 0x04E0
     800:	86 89       	ldd	r24, Z+22	; 0x16
     802:	08 17       	cp	r16, r24
     804:	20 f0       	brcs	.+8      	; 0x80e <xTaskGenericCreate+0x174>
					{
						pxCurrentTCB = pxNewTCB;
     806:	d0 93 e0 04 	sts	0x04E0, r29
     80a:	c0 93 df 04 	sts	0x04DF, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     80e:	80 91 93 04 	lds	r24, 0x0493
     812:	8f 5f       	subi	r24, 0xFF	; 255
     814:	80 93 93 04 	sts	0x0493, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     818:	8e 89       	ldd	r24, Y+22	; 0x16
     81a:	90 91 98 04 	lds	r25, 0x0498
     81e:	98 17       	cp	r25, r24
     820:	10 f4       	brcc	.+4      	; 0x826 <xTaskGenericCreate+0x18c>
     822:	80 93 98 04 	sts	0x0498, r24
     826:	f9 e0       	ldi	r31, 0x09	; 9
     828:	8f 9f       	mul	r24, r31
     82a:	c0 01       	movw	r24, r0
     82c:	11 24       	eor	r1, r1
     82e:	b6 01       	movw	r22, r12
     830:	85 54       	subi	r24, 0x45	; 69
     832:	9b 4f       	sbci	r25, 0xFB	; 251
     834:	0e 94 98 02 	call	0x530	; 0x530 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     838:	0f 90       	pop	r0
     83a:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     83c:	80 91 97 04 	lds	r24, 0x0497
     840:	88 23       	and	r24, r24
     842:	49 f0       	breq	.+18     	; 0x856 <xTaskGenericCreate+0x1bc>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     844:	e0 91 df 04 	lds	r30, 0x04DF
     848:	f0 91 e0 04 	lds	r31, 0x04E0
     84c:	86 89       	ldd	r24, Z+22	; 0x16
     84e:	80 17       	cp	r24, r16
     850:	10 f4       	brcc	.+4      	; 0x856 <xTaskGenericCreate+0x1bc>
			{
				taskYIELD_IF_USING_PREEMPTION();
     852:	0e 94 9b 01 	call	0x336	; 0x336 <vPortYield>
     856:	81 e0       	ldi	r24, 0x01	; 1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     858:	df 91       	pop	r29
     85a:	cf 91       	pop	r28
     85c:	1f 91       	pop	r17
     85e:	0f 91       	pop	r16
     860:	ff 90       	pop	r15
     862:	ef 90       	pop	r14
     864:	df 90       	pop	r13
     866:	cf 90       	pop	r12
     868:	bf 90       	pop	r11
     86a:	af 90       	pop	r10
     86c:	9f 90       	pop	r9
     86e:	8f 90       	pop	r8
     870:	7f 90       	pop	r7
     872:	6f 90       	pop	r6
     874:	5f 90       	pop	r5
     876:	08 95       	ret

00000878 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     878:	af 92       	push	r10
     87a:	bf 92       	push	r11
     87c:	cf 92       	push	r12
     87e:	df 92       	push	r13
     880:	ef 92       	push	r14
     882:	ff 92       	push	r15
     884:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     886:	a1 2c       	mov	r10, r1
     888:	b1 2c       	mov	r11, r1
     88a:	c1 2c       	mov	r12, r1
     88c:	d1 2c       	mov	r13, r1
     88e:	e1 2c       	mov	r14, r1
     890:	f1 2c       	mov	r15, r1
     892:	00 e0       	ldi	r16, 0x00	; 0
     894:	20 e0       	ldi	r18, 0x00	; 0
     896:	30 e0       	ldi	r19, 0x00	; 0
     898:	45 e5       	ldi	r20, 0x55	; 85
     89a:	50 e0       	ldi	r21, 0x00	; 0
     89c:	69 e1       	ldi	r22, 0x19	; 25
     89e:	71 e0       	ldi	r23, 0x01	; 1
     8a0:	84 e1       	ldi	r24, 0x14	; 20
     8a2:	93 e0       	ldi	r25, 0x03	; 3
     8a4:	0e 94 4d 03 	call	0x69a	; 0x69a <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     8a8:	81 30       	cpi	r24, 0x01	; 1
     8aa:	81 f4       	brne	.+32     	; 0x8cc <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     8ac:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
     8ae:	80 93 97 04 	sts	0x0497, r24
		xTickCount = ( TickType_t ) 0U;
     8b2:	10 92 9a 04 	sts	0x049A, r1
     8b6:	10 92 99 04 	sts	0x0499, r1
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     8ba:	0f 91       	pop	r16
     8bc:	ff 90       	pop	r15
     8be:	ef 90       	pop	r14
     8c0:	df 90       	pop	r13
     8c2:	cf 90       	pop	r12
     8c4:	bf 90       	pop	r11
     8c6:	af 90       	pop	r10
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     8c8:	0c 94 61 01 	jmp	0x2c2	; 0x2c2 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     8cc:	0f 91       	pop	r16
     8ce:	ff 90       	pop	r15
     8d0:	ef 90       	pop	r14
     8d2:	df 90       	pop	r13
     8d4:	cf 90       	pop	r12
     8d6:	bf 90       	pop	r11
     8d8:	af 90       	pop	r10
     8da:	08 95       	ret

000008dc <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     8dc:	80 91 92 04 	lds	r24, 0x0492
     8e0:	8f 5f       	subi	r24, 0xFF	; 255
     8e2:	80 93 92 04 	sts	0x0492, r24
     8e6:	08 95       	ret

000008e8 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     8e8:	cf 92       	push	r12
     8ea:	df 92       	push	r13
     8ec:	ef 92       	push	r14
     8ee:	ff 92       	push	r15
     8f0:	0f 93       	push	r16
     8f2:	1f 93       	push	r17
     8f4:	cf 93       	push	r28
     8f6:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     8f8:	80 91 92 04 	lds	r24, 0x0492
     8fc:	81 11       	cpse	r24, r1
     8fe:	a7 c0       	rjmp	.+334    	; 0xa4e <__stack+0x14f>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     900:	80 91 99 04 	lds	r24, 0x0499
     904:	90 91 9a 04 	lds	r25, 0x049A
     908:	01 96       	adiw	r24, 0x01	; 1
     90a:	90 93 9a 04 	sts	0x049A, r25
     90e:	80 93 99 04 	sts	0x0499, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     912:	e0 90 99 04 	lds	r14, 0x0499
     916:	f0 90 9a 04 	lds	r15, 0x049A

			if( xConstTickCount == ( TickType_t ) 0U )
     91a:	e1 14       	cp	r14, r1
     91c:	f1 04       	cpc	r15, r1
     91e:	79 f5       	brne	.+94     	; 0x97e <__stack+0x7f>
			{
				taskSWITCH_DELAYED_LISTS();
     920:	80 91 a7 04 	lds	r24, 0x04A7
     924:	90 91 a8 04 	lds	r25, 0x04A8
     928:	20 91 a5 04 	lds	r18, 0x04A5
     92c:	30 91 a6 04 	lds	r19, 0x04A6
     930:	30 93 a8 04 	sts	0x04A8, r19
     934:	20 93 a7 04 	sts	0x04A7, r18
     938:	90 93 a6 04 	sts	0x04A6, r25
     93c:	80 93 a5 04 	sts	0x04A5, r24
     940:	80 91 94 04 	lds	r24, 0x0494
     944:	8f 5f       	subi	r24, 0xFF	; 255
     946:	80 93 94 04 	sts	0x0494, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     94a:	e0 91 a7 04 	lds	r30, 0x04A7
     94e:	f0 91 a8 04 	lds	r31, 0x04A8
     952:	80 81       	ld	r24, Z
     954:	81 11       	cpse	r24, r1
     956:	03 c0       	rjmp	.+6      	; 0x95e <__stack+0x5f>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     958:	8f ef       	ldi	r24, 0xFF	; 255
     95a:	9f ef       	ldi	r25, 0xFF	; 255
     95c:	0c c0       	rjmp	.+24     	; 0x976 <__stack+0x77>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     95e:	e0 91 a7 04 	lds	r30, 0x04A7
     962:	f0 91 a8 04 	lds	r31, 0x04A8
     966:	05 80       	ldd	r0, Z+5	; 0x05
     968:	f6 81       	ldd	r31, Z+6	; 0x06
     96a:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     96c:	06 80       	ldd	r0, Z+6	; 0x06
     96e:	f7 81       	ldd	r31, Z+7	; 0x07
     970:	e0 2d       	mov	r30, r0
     972:	82 81       	ldd	r24, Z+2	; 0x02
     974:	93 81       	ldd	r25, Z+3	; 0x03
     976:	90 93 01 01 	sts	0x0101, r25
     97a:	80 93 00 01 	sts	0x0100, r24

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     97e:	80 91 00 01 	lds	r24, 0x0100
     982:	90 91 01 01 	lds	r25, 0x0101
     986:	c0 e0       	ldi	r28, 0x00	; 0
     988:	e8 16       	cp	r14, r24
     98a:	f9 06       	cpc	r15, r25
     98c:	08 f4       	brcc	.+2      	; 0x990 <__stack+0x91>
     98e:	4f c0       	rjmp	.+158    	; 0xa2e <__stack+0x12f>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     990:	d9 e0       	ldi	r29, 0x09	; 9
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     992:	e0 91 a7 04 	lds	r30, 0x04A7
     996:	f0 91 a8 04 	lds	r31, 0x04A8
     99a:	80 81       	ld	r24, Z
     99c:	81 11       	cpse	r24, r1
     99e:	03 c0       	rjmp	.+6      	; 0x9a6 <__stack+0xa7>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     9a0:	8f ef       	ldi	r24, 0xFF	; 255
     9a2:	9f ef       	ldi	r25, 0xFF	; 255
     9a4:	11 c0       	rjmp	.+34     	; 0x9c8 <__stack+0xc9>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     9a6:	e0 91 a7 04 	lds	r30, 0x04A7
     9aa:	f0 91 a8 04 	lds	r31, 0x04A8
     9ae:	05 80       	ldd	r0, Z+5	; 0x05
     9b0:	f6 81       	ldd	r31, Z+6	; 0x06
     9b2:	e0 2d       	mov	r30, r0
     9b4:	06 81       	ldd	r16, Z+6	; 0x06
     9b6:	17 81       	ldd	r17, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     9b8:	d8 01       	movw	r26, r16
     9ba:	12 96       	adiw	r26, 0x02	; 2
     9bc:	8d 91       	ld	r24, X+
     9be:	9c 91       	ld	r25, X
     9c0:	13 97       	sbiw	r26, 0x03	; 3

						if( xConstTickCount < xItemValue )
     9c2:	e8 16       	cp	r14, r24
     9c4:	f9 06       	cpc	r15, r25
     9c6:	28 f4       	brcc	.+10     	; 0x9d2 <__stack+0xd3>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     9c8:	90 93 01 01 	sts	0x0101, r25
     9cc:	80 93 00 01 	sts	0x0100, r24
							break;
     9d0:	2e c0       	rjmp	.+92     	; 0xa2e <__stack+0x12f>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     9d2:	68 01       	movw	r12, r16
     9d4:	b2 e0       	ldi	r27, 0x02	; 2
     9d6:	cb 0e       	add	r12, r27
     9d8:	d1 1c       	adc	r13, r1
     9da:	c6 01       	movw	r24, r12
     9dc:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     9e0:	f8 01       	movw	r30, r16
     9e2:	84 89       	ldd	r24, Z+20	; 0x14
     9e4:	95 89       	ldd	r25, Z+21	; 0x15
     9e6:	89 2b       	or	r24, r25
     9e8:	21 f0       	breq	.+8      	; 0x9f2 <__stack+0xf3>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     9ea:	c8 01       	movw	r24, r16
     9ec:	0c 96       	adiw	r24, 0x0c	; 12
     9ee:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     9f2:	d8 01       	movw	r26, r16
     9f4:	56 96       	adiw	r26, 0x16	; 22
     9f6:	9c 91       	ld	r25, X
     9f8:	80 91 98 04 	lds	r24, 0x0498
     9fc:	89 17       	cp	r24, r25
     9fe:	10 f4       	brcc	.+4      	; 0xa04 <__stack+0x105>
     a00:	90 93 98 04 	sts	0x0498, r25
     a04:	d9 9f       	mul	r29, r25
     a06:	c0 01       	movw	r24, r0
     a08:	11 24       	eor	r1, r1
     a0a:	b6 01       	movw	r22, r12
     a0c:	85 54       	subi	r24, 0x45	; 69
     a0e:	9b 4f       	sbci	r25, 0xFB	; 251
     a10:	0e 94 98 02 	call	0x530	; 0x530 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     a14:	e0 91 df 04 	lds	r30, 0x04DF
     a18:	f0 91 e0 04 	lds	r31, 0x04E0
     a1c:	d8 01       	movw	r26, r16
     a1e:	56 96       	adiw	r26, 0x16	; 22
     a20:	9c 91       	ld	r25, X
     a22:	86 89       	ldd	r24, Z+22	; 0x16
     a24:	98 17       	cp	r25, r24
     a26:	08 f4       	brcc	.+2      	; 0xa2a <__stack+0x12b>
     a28:	b4 cf       	rjmp	.-152    	; 0x992 <__stack+0x93>
							{
								xSwitchRequired = pdTRUE;
     a2a:	c1 e0       	ldi	r28, 0x01	; 1
     a2c:	b2 cf       	rjmp	.-156    	; 0x992 <__stack+0x93>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     a2e:	e0 91 df 04 	lds	r30, 0x04DF
     a32:	f0 91 e0 04 	lds	r31, 0x04E0
     a36:	e6 89       	ldd	r30, Z+22	; 0x16
     a38:	b9 e0       	ldi	r27, 0x09	; 9
     a3a:	eb 9f       	mul	r30, r27
     a3c:	f0 01       	movw	r30, r0
     a3e:	11 24       	eor	r1, r1
     a40:	e5 54       	subi	r30, 0x45	; 69
     a42:	fb 4f       	sbci	r31, 0xFB	; 251
     a44:	80 81       	ld	r24, Z
     a46:	82 30       	cpi	r24, 0x02	; 2
     a48:	40 f0       	brcs	.+16     	; 0xa5a <__stack+0x15b>
			{
				xSwitchRequired = pdTRUE;
     a4a:	c1 e0       	ldi	r28, 0x01	; 1
     a4c:	06 c0       	rjmp	.+12     	; 0xa5a <__stack+0x15b>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     a4e:	80 91 96 04 	lds	r24, 0x0496
     a52:	8f 5f       	subi	r24, 0xFF	; 255
     a54:	80 93 96 04 	sts	0x0496, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     a58:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     a5a:	80 91 95 04 	lds	r24, 0x0495
     a5e:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
     a60:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     a62:	8c 2f       	mov	r24, r28
     a64:	df 91       	pop	r29
     a66:	cf 91       	pop	r28
     a68:	1f 91       	pop	r17
     a6a:	0f 91       	pop	r16
     a6c:	ff 90       	pop	r15
     a6e:	ef 90       	pop	r14
     a70:	df 90       	pop	r13
     a72:	cf 90       	pop	r12
     a74:	08 95       	ret

00000a76 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     a76:	ef 92       	push	r14
     a78:	ff 92       	push	r15
     a7a:	0f 93       	push	r16
     a7c:	1f 93       	push	r17
     a7e:	cf 93       	push	r28
     a80:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     a82:	0f b6       	in	r0, 0x3f	; 63
     a84:	f8 94       	cli
     a86:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     a88:	80 91 92 04 	lds	r24, 0x0492
     a8c:	81 50       	subi	r24, 0x01	; 1
     a8e:	80 93 92 04 	sts	0x0492, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     a92:	80 91 92 04 	lds	r24, 0x0492
     a96:	88 23       	and	r24, r24
     a98:	11 f0       	breq	.+4      	; 0xa9e <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     a9a:	80 e0       	ldi	r24, 0x00	; 0
     a9c:	53 c0       	rjmp	.+166    	; 0xb44 <xTaskResumeAll+0xce>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     a9e:	80 91 9b 04 	lds	r24, 0x049B
     aa2:	88 23       	and	r24, r24
     aa4:	d1 f3       	breq	.-12     	; 0xa9a <xTaskResumeAll+0x24>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
     aa6:	89 e0       	ldi	r24, 0x09	; 9
     aa8:	f8 2e       	mov	r15, r24

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     aaa:	ee 24       	eor	r14, r14
     aac:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     aae:	80 91 9c 04 	lds	r24, 0x049C
     ab2:	88 23       	and	r24, r24
     ab4:	51 f1       	breq	.+84     	; 0xb0a <xTaskResumeAll+0x94>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     ab6:	e0 91 a1 04 	lds	r30, 0x04A1
     aba:	f0 91 a2 04 	lds	r31, 0x04A2
     abe:	c6 81       	ldd	r28, Z+6	; 0x06
     ac0:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     ac2:	ce 01       	movw	r24, r28
     ac4:	0c 96       	adiw	r24, 0x0c	; 12
     ac6:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     aca:	8e 01       	movw	r16, r28
     acc:	0e 5f       	subi	r16, 0xFE	; 254
     ace:	1f 4f       	sbci	r17, 0xFF	; 255
     ad0:	c8 01       	movw	r24, r16
     ad2:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     ad6:	9e 89       	ldd	r25, Y+22	; 0x16
     ad8:	80 91 98 04 	lds	r24, 0x0498
     adc:	89 17       	cp	r24, r25
     ade:	10 f4       	brcc	.+4      	; 0xae4 <xTaskResumeAll+0x6e>
     ae0:	90 93 98 04 	sts	0x0498, r25
     ae4:	f9 9e       	mul	r15, r25
     ae6:	c0 01       	movw	r24, r0
     ae8:	11 24       	eor	r1, r1
     aea:	b8 01       	movw	r22, r16
     aec:	85 54       	subi	r24, 0x45	; 69
     aee:	9b 4f       	sbci	r25, 0xFB	; 251
     af0:	0e 94 98 02 	call	0x530	; 0x530 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     af4:	e0 91 df 04 	lds	r30, 0x04DF
     af8:	f0 91 e0 04 	lds	r31, 0x04E0
     afc:	9e 89       	ldd	r25, Y+22	; 0x16
     afe:	86 89       	ldd	r24, Z+22	; 0x16
     b00:	98 17       	cp	r25, r24
     b02:	a8 f2       	brcs	.-86     	; 0xaae <xTaskResumeAll+0x38>
					{
						xYieldPending = pdTRUE;
     b04:	e0 92 95 04 	sts	0x0495, r14
     b08:	d2 cf       	rjmp	.-92     	; 0xaae <xTaskResumeAll+0x38>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     b0a:	80 91 96 04 	lds	r24, 0x0496
     b0e:	81 11       	cpse	r24, r1
     b10:	09 c0       	rjmp	.+18     	; 0xb24 <xTaskResumeAll+0xae>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     b12:	80 91 95 04 	lds	r24, 0x0495
     b16:	81 30       	cpi	r24, 0x01	; 1
     b18:	09 f0       	breq	.+2      	; 0xb1c <xTaskResumeAll+0xa6>
     b1a:	bf cf       	rjmp	.-130    	; 0xa9a <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     b1c:	0e 94 9b 01 	call	0x336	; 0x336 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     b20:	81 e0       	ldi	r24, 0x01	; 1
     b22:	10 c0       	rjmp	.+32     	; 0xb44 <xTaskResumeAll+0xce>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     b24:	c1 e0       	ldi	r28, 0x01	; 1
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     b26:	80 91 96 04 	lds	r24, 0x0496
     b2a:	88 23       	and	r24, r24
     b2c:	91 f3       	breq	.-28     	; 0xb12 <xTaskResumeAll+0x9c>
					{
						if( xTaskIncrementTick() != pdFALSE )
     b2e:	0e 94 74 04 	call	0x8e8	; 0x8e8 <xTaskIncrementTick>
     b32:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
     b34:	c0 93 95 04 	sts	0x0495, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     b38:	80 91 96 04 	lds	r24, 0x0496
     b3c:	81 50       	subi	r24, 0x01	; 1
     b3e:	80 93 96 04 	sts	0x0496, r24
     b42:	f1 cf       	rjmp	.-30     	; 0xb26 <xTaskResumeAll+0xb0>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     b44:	0f 90       	pop	r0
     b46:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     b48:	df 91       	pop	r29
     b4a:	cf 91       	pop	r28
     b4c:	1f 91       	pop	r17
     b4e:	0f 91       	pop	r16
     b50:	ff 90       	pop	r15
     b52:	ef 90       	pop	r14
     b54:	08 95       	ret

00000b56 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
     b56:	cf 93       	push	r28
     b58:	df 93       	push	r29
     b5a:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
     b5c:	89 2b       	or	r24, r25
     b5e:	19 f4       	brne	.+6      	; 0xb66 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     b60:	0e 94 9b 01 	call	0x336	; 0x336 <vPortYield>
     b64:	16 c0       	rjmp	.+44     	; 0xb92 <vTaskDelay+0x3c>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
     b66:	0e 94 6e 04 	call	0x8dc	; 0x8dc <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     b6a:	20 91 99 04 	lds	r18, 0x0499
     b6e:	30 91 9a 04 	lds	r19, 0x049A
     b72:	c2 0f       	add	r28, r18
     b74:	d3 1f       	adc	r29, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     b76:	80 91 df 04 	lds	r24, 0x04DF
     b7a:	90 91 e0 04 	lds	r25, 0x04E0
     b7e:	02 96       	adiw	r24, 0x02	; 2
     b80:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     b84:	ce 01       	movw	r24, r28
     b86:	0e 94 15 03 	call	0x62a	; 0x62a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     b8a:	0e 94 3b 05 	call	0xa76	; 0xa76 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     b8e:	88 23       	and	r24, r24
     b90:	39 f3       	breq	.-50     	; 0xb60 <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     b92:	df 91       	pop	r29
     b94:	cf 91       	pop	r28
     b96:	08 95       	ret

00000b98 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     b98:	80 91 92 04 	lds	r24, 0x0492
     b9c:	88 23       	and	r24, r24
     b9e:	21 f0       	breq	.+8      	; 0xba8 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     ba0:	81 e0       	ldi	r24, 0x01	; 1
     ba2:	80 93 95 04 	sts	0x0495, r24
     ba6:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     ba8:	10 92 95 04 	sts	0x0495, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     bac:	99 e0       	ldi	r25, 0x09	; 9
     bae:	e0 91 98 04 	lds	r30, 0x0498
     bb2:	9e 9f       	mul	r25, r30
     bb4:	f0 01       	movw	r30, r0
     bb6:	11 24       	eor	r1, r1
     bb8:	e5 54       	subi	r30, 0x45	; 69
     bba:	fb 4f       	sbci	r31, 0xFB	; 251
     bbc:	80 81       	ld	r24, Z
     bbe:	81 11       	cpse	r24, r1
     bc0:	06 c0       	rjmp	.+12     	; 0xbce <vTaskSwitchContext+0x36>
     bc2:	80 91 98 04 	lds	r24, 0x0498
     bc6:	81 50       	subi	r24, 0x01	; 1
     bc8:	80 93 98 04 	sts	0x0498, r24
     bcc:	f0 cf       	rjmp	.-32     	; 0xbae <vTaskSwitchContext+0x16>
     bce:	80 91 98 04 	lds	r24, 0x0498
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	49 e0       	ldi	r20, 0x09	; 9
     bd6:	48 9f       	mul	r20, r24
     bd8:	90 01       	movw	r18, r0
     bda:	49 9f       	mul	r20, r25
     bdc:	30 0d       	add	r19, r0
     bde:	11 24       	eor	r1, r1
     be0:	f9 01       	movw	r30, r18
     be2:	e5 54       	subi	r30, 0x45	; 69
     be4:	fb 4f       	sbci	r31, 0xFB	; 251
     be6:	a1 81       	ldd	r26, Z+1	; 0x01
     be8:	b2 81       	ldd	r27, Z+2	; 0x02
     bea:	12 96       	adiw	r26, 0x02	; 2
     bec:	0d 90       	ld	r0, X+
     bee:	bc 91       	ld	r27, X
     bf0:	a0 2d       	mov	r26, r0
     bf2:	b2 83       	std	Z+2, r27	; 0x02
     bf4:	a1 83       	std	Z+1, r26	; 0x01
     bf6:	22 54       	subi	r18, 0x42	; 66
     bf8:	3b 4f       	sbci	r19, 0xFB	; 251
     bfa:	a2 17       	cp	r26, r18
     bfc:	b3 07       	cpc	r27, r19
     bfe:	31 f4       	brne	.+12     	; 0xc0c <vTaskSwitchContext+0x74>
     c00:	12 96       	adiw	r26, 0x02	; 2
     c02:	2d 91       	ld	r18, X+
     c04:	3c 91       	ld	r19, X
     c06:	13 97       	sbiw	r26, 0x03	; 3
     c08:	32 83       	std	Z+2, r19	; 0x02
     c0a:	21 83       	std	Z+1, r18	; 0x01
     c0c:	29 e0       	ldi	r18, 0x09	; 9
     c0e:	28 9f       	mul	r18, r24
     c10:	f0 01       	movw	r30, r0
     c12:	29 9f       	mul	r18, r25
     c14:	f0 0d       	add	r31, r0
     c16:	11 24       	eor	r1, r1
     c18:	e5 54       	subi	r30, 0x45	; 69
     c1a:	fb 4f       	sbci	r31, 0xFB	; 251
     c1c:	01 80       	ldd	r0, Z+1	; 0x01
     c1e:	f2 81       	ldd	r31, Z+2	; 0x02
     c20:	e0 2d       	mov	r30, r0
     c22:	86 81       	ldd	r24, Z+6	; 0x06
     c24:	97 81       	ldd	r25, Z+7	; 0x07
     c26:	90 93 e0 04 	sts	0x04E0, r25
     c2a:	80 93 df 04 	sts	0x04DF, r24
     c2e:	08 95       	ret

00000c30 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     c30:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     c32:	91 8d       	ldd	r25, Z+25	; 0x19
     c34:	22 8d       	ldd	r18, Z+26	; 0x1a
     c36:	89 2f       	mov	r24, r25
     c38:	90 e0       	ldi	r25, 0x00	; 0
     c3a:	80 5c       	subi	r24, 0xC0	; 192
     c3c:	9f 4f       	sbci	r25, 0xFF	; 255
     c3e:	82 1b       	sub	r24, r18
     c40:	91 09       	sbc	r25, r1
}
     c42:	8f 73       	andi	r24, 0x3F	; 63
     c44:	99 27       	eor	r25, r25
     c46:	08 95       	ret

00000c48 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
     c48:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
     c4a:	91 8d       	ldd	r25, Z+25	; 0x19
     c4c:	82 8d       	ldd	r24, Z+26	; 0x1a
     c4e:	98 17       	cp	r25, r24
     c50:	31 f0       	breq	.+12     	; 0xc5e <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     c52:	82 8d       	ldd	r24, Z+26	; 0x1a
     c54:	e8 0f       	add	r30, r24
     c56:	f1 1d       	adc	r31, r1
     c58:	85 8d       	ldd	r24, Z+29	; 0x1d
     c5a:	90 e0       	ldi	r25, 0x00	; 0
     c5c:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     c5e:	8f ef       	ldi	r24, 0xFF	; 255
     c60:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     c62:	08 95       	ret

00000c64 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
     c64:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     c66:	91 8d       	ldd	r25, Z+25	; 0x19
     c68:	82 8d       	ldd	r24, Z+26	; 0x1a
     c6a:	98 17       	cp	r25, r24
     c6c:	61 f0       	breq	.+24     	; 0xc86 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     c6e:	82 8d       	ldd	r24, Z+26	; 0x1a
     c70:	df 01       	movw	r26, r30
     c72:	a8 0f       	add	r26, r24
     c74:	b1 1d       	adc	r27, r1
     c76:	5d 96       	adiw	r26, 0x1d	; 29
     c78:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     c7a:	92 8d       	ldd	r25, Z+26	; 0x1a
     c7c:	9f 5f       	subi	r25, 0xFF	; 255
     c7e:	9f 73       	andi	r25, 0x3F	; 63
     c80:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
     c82:	90 e0       	ldi	r25, 0x00	; 0
     c84:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     c86:	8f ef       	ldi	r24, 0xFF	; 255
     c88:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     c8a:	08 95       	ret

00000c8c <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     c8c:	8b e9       	ldi	r24, 0x9B	; 155
     c8e:	97 e0       	ldi	r25, 0x07	; 7
     c90:	89 2b       	or	r24, r25
     c92:	49 f0       	breq	.+18     	; 0xca6 <_Z14serialEventRunv+0x1a>
     c94:	80 e0       	ldi	r24, 0x00	; 0
     c96:	90 e0       	ldi	r25, 0x00	; 0
     c98:	89 2b       	or	r24, r25
     c9a:	29 f0       	breq	.+10     	; 0xca6 <_Z14serialEventRunv+0x1a>
     c9c:	0e 94 9b 07 	call	0xf36	; 0xf36 <_Z17Serial0_availablev>
     ca0:	81 11       	cpse	r24, r1
     ca2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
     ca6:	08 95       	ret

00000ca8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     ca8:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     caa:	84 8d       	ldd	r24, Z+28	; 0x1c
     cac:	df 01       	movw	r26, r30
     cae:	a8 0f       	add	r26, r24
     cb0:	b1 1d       	adc	r27, r1
     cb2:	a3 5a       	subi	r26, 0xA3	; 163
     cb4:	bf 4f       	sbci	r27, 0xFF	; 255
     cb6:	2c 91       	ld	r18, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     cb8:	84 8d       	ldd	r24, Z+28	; 0x1c
     cba:	90 e0       	ldi	r25, 0x00	; 0
     cbc:	01 96       	adiw	r24, 0x01	; 1
     cbe:	8f 73       	andi	r24, 0x3F	; 63
     cc0:	99 27       	eor	r25, r25
     cc2:	84 8f       	std	Z+28, r24	; 0x1c

  *_udr = c;
     cc4:	a6 89       	ldd	r26, Z+22	; 0x16
     cc6:	b7 89       	ldd	r27, Z+23	; 0x17
     cc8:	2c 93       	st	X, r18

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
     cca:	a0 89       	ldd	r26, Z+16	; 0x10
     ccc:	b1 89       	ldd	r27, Z+17	; 0x11
     cce:	8c 91       	ld	r24, X
     cd0:	80 64       	ori	r24, 0x40	; 64
     cd2:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
     cd4:	93 8d       	ldd	r25, Z+27	; 0x1b
     cd6:	84 8d       	ldd	r24, Z+28	; 0x1c
     cd8:	98 13       	cpse	r25, r24
     cda:	06 c0       	rjmp	.+12     	; 0xce8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x40>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
     cdc:	02 88       	ldd	r0, Z+18	; 0x12
     cde:	f3 89       	ldd	r31, Z+19	; 0x13
     ce0:	e0 2d       	mov	r30, r0
     ce2:	80 81       	ld	r24, Z
     ce4:	8f 7d       	andi	r24, 0xDF	; 223
     ce6:	80 83       	st	Z, r24
     ce8:	08 95       	ret

00000cea <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     cea:	cf 93       	push	r28
     cec:	df 93       	push	r29
     cee:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     cf0:	88 8d       	ldd	r24, Y+24	; 0x18
     cf2:	88 23       	and	r24, r24
     cf4:	c9 f0       	breq	.+50     	; 0xd28 <_ZN14HardwareSerial5flushEv+0x3e>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     cf6:	ea 89       	ldd	r30, Y+18	; 0x12
     cf8:	fb 89       	ldd	r31, Y+19	; 0x13
     cfa:	80 81       	ld	r24, Z
     cfc:	85 fd       	sbrc	r24, 5
     cfe:	05 c0       	rjmp	.+10     	; 0xd0a <_ZN14HardwareSerial5flushEv+0x20>
     d00:	a8 89       	ldd	r26, Y+16	; 0x10
     d02:	b9 89       	ldd	r27, Y+17	; 0x11
     d04:	8c 91       	ld	r24, X
     d06:	86 fd       	sbrc	r24, 6
     d08:	0f c0       	rjmp	.+30     	; 0xd28 <_ZN14HardwareSerial5flushEv+0x3e>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     d0a:	0f b6       	in	r0, 0x3f	; 63
     d0c:	07 fc       	sbrc	r0, 7
     d0e:	f5 cf       	rjmp	.-22     	; 0xcfa <_ZN14HardwareSerial5flushEv+0x10>
     d10:	80 81       	ld	r24, Z
     d12:	85 ff       	sbrs	r24, 5
     d14:	f2 cf       	rjmp	.-28     	; 0xcfa <_ZN14HardwareSerial5flushEv+0x10>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
     d16:	a8 89       	ldd	r26, Y+16	; 0x10
     d18:	b9 89       	ldd	r27, Y+17	; 0x11
     d1a:	8c 91       	ld	r24, X
     d1c:	85 ff       	sbrs	r24, 5
     d1e:	ed cf       	rjmp	.-38     	; 0xcfa <_ZN14HardwareSerial5flushEv+0x10>
	  _tx_udr_empty_irq();
     d20:	ce 01       	movw	r24, r28
     d22:	0e 94 54 06 	call	0xca8	; 0xca8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     d26:	e7 cf       	rjmp	.-50     	; 0xcf6 <_ZN14HardwareSerial5flushEv+0xc>
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     d28:	df 91       	pop	r29
     d2a:	cf 91       	pop	r28
     d2c:	08 95       	ret

00000d2e <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
     d2e:	ef 92       	push	r14
     d30:	ff 92       	push	r15
     d32:	0f 93       	push	r16
     d34:	1f 93       	push	r17
     d36:	cf 93       	push	r28
     d38:	df 93       	push	r29
     d3a:	ec 01       	movw	r28, r24
  _written = true;
     d3c:	81 e0       	ldi	r24, 0x01	; 1
     d3e:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     d40:	9b 8d       	ldd	r25, Y+27	; 0x1b
     d42:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d44:	98 13       	cpse	r25, r24
     d46:	05 c0       	rjmp	.+10     	; 0xd52 <_ZN14HardwareSerial5writeEh+0x24>
     d48:	e8 89       	ldd	r30, Y+16	; 0x10
     d4a:	f9 89       	ldd	r31, Y+17	; 0x11
     d4c:	80 81       	ld	r24, Z
     d4e:	85 fd       	sbrc	r24, 5
     d50:	24 c0       	rjmp	.+72     	; 0xd9a <_ZN14HardwareSerial5writeEh+0x6c>
     d52:	f6 2e       	mov	r15, r22
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     d54:	0b 8d       	ldd	r16, Y+27	; 0x1b
     d56:	10 e0       	ldi	r17, 0x00	; 0
     d58:	0f 5f       	subi	r16, 0xFF	; 255
     d5a:	1f 4f       	sbci	r17, 0xFF	; 255
     d5c:	0f 73       	andi	r16, 0x3F	; 63
     d5e:	11 27       	eor	r17, r17
     d60:	e0 2e       	mov	r14, r16
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     d62:	8c 8d       	ldd	r24, Y+28	; 0x1c
     d64:	e8 12       	cpse	r14, r24
     d66:	0c c0       	rjmp	.+24     	; 0xd80 <_ZN14HardwareSerial5writeEh+0x52>
    if (bit_is_clear(SREG, SREG_I)) {
     d68:	0f b6       	in	r0, 0x3f	; 63
     d6a:	07 fc       	sbrc	r0, 7
     d6c:	fa cf       	rjmp	.-12     	; 0xd62 <_ZN14HardwareSerial5writeEh+0x34>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     d6e:	e8 89       	ldd	r30, Y+16	; 0x10
     d70:	f9 89       	ldd	r31, Y+17	; 0x11
     d72:	80 81       	ld	r24, Z
     d74:	85 ff       	sbrs	r24, 5
     d76:	f5 cf       	rjmp	.-22     	; 0xd62 <_ZN14HardwareSerial5writeEh+0x34>
	_tx_udr_empty_irq();
     d78:	ce 01       	movw	r24, r28
     d7a:	0e 94 54 06 	call	0xca8	; 0xca8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
     d7e:	f1 cf       	rjmp	.-30     	; 0xd62 <_ZN14HardwareSerial5writeEh+0x34>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     d80:	8b 8d       	ldd	r24, Y+27	; 0x1b
     d82:	fe 01       	movw	r30, r28
     d84:	e8 0f       	add	r30, r24
     d86:	f1 1d       	adc	r31, r1
     d88:	e3 5a       	subi	r30, 0xA3	; 163
     d8a:	ff 4f       	sbci	r31, 0xFF	; 255
     d8c:	f0 82       	st	Z, r15
  _tx_buffer_head = i;
     d8e:	0b 8f       	std	Y+27, r16	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
     d90:	ea 89       	ldd	r30, Y+18	; 0x12
     d92:	fb 89       	ldd	r31, Y+19	; 0x13
     d94:	80 81       	ld	r24, Z
     d96:	80 62       	ori	r24, 0x20	; 32
     d98:	07 c0       	rjmp	.+14     	; 0xda8 <_ZN14HardwareSerial5writeEh+0x7a>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
     d9a:	ee 89       	ldd	r30, Y+22	; 0x16
     d9c:	ff 89       	ldd	r31, Y+23	; 0x17
     d9e:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
     da0:	e8 89       	ldd	r30, Y+16	; 0x10
     da2:	f9 89       	ldd	r31, Y+17	; 0x11
     da4:	80 81       	ld	r24, Z
     da6:	80 64       	ori	r24, 0x40	; 64
     da8:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
     daa:	81 e0       	ldi	r24, 0x01	; 1
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	df 91       	pop	r29
     db0:	cf 91       	pop	r28
     db2:	1f 91       	pop	r17
     db4:	0f 91       	pop	r16
     db6:	ff 90       	pop	r15
     db8:	ef 90       	pop	r14
     dba:	08 95       	ret

00000dbc <_ZN14HardwareSerial5beginEmh>:
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
     dbc:	cf 92       	push	r12
     dbe:	df 92       	push	r13
     dc0:	ef 92       	push	r14
     dc2:	ff 92       	push	r15
     dc4:	1f 93       	push	r17
     dc6:	cf 93       	push	r28
     dc8:	df 93       	push	r29
     dca:	ec 01       	movw	r28, r24
     dcc:	6a 01       	movw	r12, r20
     dce:	7b 01       	movw	r14, r22
     dd0:	12 2f       	mov	r17, r18
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
     dd2:	e8 89       	ldd	r30, Y+16	; 0x10
     dd4:	f9 89       	ldd	r31, Y+17	; 0x11
     dd6:	82 e0       	ldi	r24, 0x02	; 2
     dd8:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     dda:	41 15       	cp	r20, r1
     ddc:	51 4e       	sbci	r21, 0xE1	; 225
     dde:	61 05       	cpc	r22, r1
     de0:	71 05       	cpc	r23, r1
     de2:	b1 f0       	breq	.+44     	; 0xe10 <_ZN14HardwareSerial5beginEmh+0x54>
// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
     de4:	60 e0       	ldi	r22, 0x00	; 0
     de6:	79 e0       	ldi	r23, 0x09	; 9
     de8:	8d e3       	ldi	r24, 0x3D	; 61
     dea:	90 e0       	ldi	r25, 0x00	; 0
     dec:	a7 01       	movw	r20, r14
     dee:	96 01       	movw	r18, r12
     df0:	0e 94 52 09 	call	0x12a4	; 0x12a4 <__udivmodsi4>
     df4:	da 01       	movw	r26, r20
     df6:	c9 01       	movw	r24, r18
     df8:	01 97       	sbiw	r24, 0x01	; 1
     dfa:	a1 09       	sbc	r26, r1
     dfc:	b1 09       	sbc	r27, r1
     dfe:	b6 95       	lsr	r27
     e00:	a7 95       	ror	r26
     e02:	97 95       	ror	r25
     e04:	87 95       	ror	r24
     e06:	ac 01       	movw	r20, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((F_CPU == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
     e08:	41 15       	cp	r20, r1
     e0a:	80 e1       	ldi	r24, 0x10	; 16
     e0c:	58 07       	cpc	r21, r24
     e0e:	a8 f0       	brcs	.+42     	; 0xe3a <_ZN14HardwareSerial5beginEmh+0x7e>
  {
    *_ucsra = 0;
     e10:	e8 89       	ldd	r30, Y+16	; 0x10
     e12:	f9 89       	ldd	r31, Y+17	; 0x11
     e14:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
     e16:	60 e8       	ldi	r22, 0x80	; 128
     e18:	74 e8       	ldi	r23, 0x84	; 132
     e1a:	8e e1       	ldi	r24, 0x1E	; 30
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	a7 01       	movw	r20, r14
     e20:	96 01       	movw	r18, r12
     e22:	0e 94 52 09 	call	0x12a4	; 0x12a4 <__udivmodsi4>
     e26:	ba 01       	movw	r22, r20
     e28:	a9 01       	movw	r20, r18
     e2a:	41 50       	subi	r20, 0x01	; 1
     e2c:	51 09       	sbc	r21, r1
     e2e:	61 09       	sbc	r22, r1
     e30:	71 09       	sbc	r23, r1
     e32:	76 95       	lsr	r23
     e34:	67 95       	ror	r22
     e36:	57 95       	ror	r21
     e38:	47 95       	ror	r20
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
     e3a:	ec 85       	ldd	r30, Y+12	; 0x0c
     e3c:	fd 85       	ldd	r31, Y+13	; 0x0d
     e3e:	50 83       	st	Z, r21
  *_ubrrl = baud_setting;
     e40:	ee 85       	ldd	r30, Y+14	; 0x0e
     e42:	ff 85       	ldd	r31, Y+15	; 0x0f
     e44:	40 83       	st	Z, r20

  _written = false;
     e46:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
     e48:	ec 89       	ldd	r30, Y+20	; 0x14
     e4a:	fd 89       	ldd	r31, Y+21	; 0x15
     e4c:	10 83       	st	Z, r17
  
  sbi(*_ucsrb, RXEN0);
     e4e:	ea 89       	ldd	r30, Y+18	; 0x12
     e50:	fb 89       	ldd	r31, Y+19	; 0x13
     e52:	80 81       	ld	r24, Z
     e54:	80 61       	ori	r24, 0x10	; 16
     e56:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
     e58:	ea 89       	ldd	r30, Y+18	; 0x12
     e5a:	fb 89       	ldd	r31, Y+19	; 0x13
     e5c:	80 81       	ld	r24, Z
     e5e:	88 60       	ori	r24, 0x08	; 8
     e60:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
     e62:	ea 89       	ldd	r30, Y+18	; 0x12
     e64:	fb 89       	ldd	r31, Y+19	; 0x13
     e66:	80 81       	ld	r24, Z
     e68:	80 68       	ori	r24, 0x80	; 128
     e6a:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
     e6c:	ea 89       	ldd	r30, Y+18	; 0x12
     e6e:	fb 89       	ldd	r31, Y+19	; 0x13
     e70:	80 81       	ld	r24, Z
     e72:	8f 7d       	andi	r24, 0xDF	; 223
     e74:	80 83       	st	Z, r24
}
     e76:	df 91       	pop	r29
     e78:	cf 91       	pop	r28
     e7a:	1f 91       	pop	r17
     e7c:	ff 90       	pop	r15
     e7e:	ef 90       	pop	r14
     e80:	df 90       	pop	r13
     e82:	cf 90       	pop	r12
     e84:	08 95       	ret

00000e86 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
     e86:	1f 92       	push	r1
     e88:	0f 92       	push	r0
     e8a:	0f b6       	in	r0, 0x3f	; 63
     e8c:	0f 92       	push	r0
     e8e:	11 24       	eor	r1, r1
     e90:	2f 93       	push	r18
     e92:	8f 93       	push	r24
     e94:	9f 93       	push	r25
     e96:	ef 93       	push	r30
     e98:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
     e9a:	e0 91 f1 04 	lds	r30, 0x04F1
     e9e:	f0 91 f2 04 	lds	r31, 0x04F2
     ea2:	80 81       	ld	r24, Z
     ea4:	e0 91 f7 04 	lds	r30, 0x04F7
     ea8:	f0 91 f8 04 	lds	r31, 0x04F8
     eac:	82 fd       	sbrc	r24, 2
     eae:	12 c0       	rjmp	.+36     	; 0xed4 <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
     eb0:	90 81       	ld	r25, Z
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     eb2:	80 91 fa 04 	lds	r24, 0x04FA
     eb6:	8f 5f       	subi	r24, 0xFF	; 255
     eb8:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     eba:	20 91 fb 04 	lds	r18, 0x04FB
     ebe:	82 17       	cp	r24, r18
     ec0:	51 f0       	breq	.+20     	; 0xed6 <__vector_18+0x50>
      _rx_buffer[_rx_buffer_head] = c;
     ec2:	e0 91 fa 04 	lds	r30, 0x04FA
     ec6:	f0 e0       	ldi	r31, 0x00	; 0
     ec8:	ef 51       	subi	r30, 0x1F	; 31
     eca:	fb 4f       	sbci	r31, 0xFB	; 251
     ecc:	95 8f       	std	Z+29, r25	; 0x1d
      _rx_buffer_head = i;
     ece:	80 93 fa 04 	sts	0x04FA, r24
     ed2:	01 c0       	rjmp	.+2      	; 0xed6 <__vector_18+0x50>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
     ed4:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
     ed6:	ff 91       	pop	r31
     ed8:	ef 91       	pop	r30
     eda:	9f 91       	pop	r25
     edc:	8f 91       	pop	r24
     ede:	2f 91       	pop	r18
     ee0:	0f 90       	pop	r0
     ee2:	0f be       	out	0x3f, r0	; 63
     ee4:	0f 90       	pop	r0
     ee6:	1f 90       	pop	r1
     ee8:	18 95       	reti

00000eea <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
     eea:	1f 92       	push	r1
     eec:	0f 92       	push	r0
     eee:	0f b6       	in	r0, 0x3f	; 63
     ef0:	0f 92       	push	r0
     ef2:	11 24       	eor	r1, r1
     ef4:	2f 93       	push	r18
     ef6:	3f 93       	push	r19
     ef8:	4f 93       	push	r20
     efa:	5f 93       	push	r21
     efc:	6f 93       	push	r22
     efe:	7f 93       	push	r23
     f00:	8f 93       	push	r24
     f02:	9f 93       	push	r25
     f04:	af 93       	push	r26
     f06:	bf 93       	push	r27
     f08:	ef 93       	push	r30
     f0a:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
     f0c:	81 ee       	ldi	r24, 0xE1	; 225
     f0e:	94 e0       	ldi	r25, 0x04	; 4
     f10:	0e 94 54 06 	call	0xca8	; 0xca8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
     f14:	ff 91       	pop	r31
     f16:	ef 91       	pop	r30
     f18:	bf 91       	pop	r27
     f1a:	af 91       	pop	r26
     f1c:	9f 91       	pop	r25
     f1e:	8f 91       	pop	r24
     f20:	7f 91       	pop	r23
     f22:	6f 91       	pop	r22
     f24:	5f 91       	pop	r21
     f26:	4f 91       	pop	r20
     f28:	3f 91       	pop	r19
     f2a:	2f 91       	pop	r18
     f2c:	0f 90       	pop	r0
     f2e:	0f be       	out	0x3f, r0	; 63
     f30:	0f 90       	pop	r0
     f32:	1f 90       	pop	r1
     f34:	18 95       	reti

00000f36 <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     f36:	81 ee       	ldi	r24, 0xE1	; 225
     f38:	94 e0       	ldi	r25, 0x04	; 4
     f3a:	0e 94 18 06 	call	0xc30	; 0xc30 <_ZN14HardwareSerial9availableEv>
     f3e:	21 e0       	ldi	r18, 0x01	; 1
     f40:	89 2b       	or	r24, r25
     f42:	09 f4       	brne	.+2      	; 0xf46 <_Z17Serial0_availablev+0x10>
     f44:	20 e0       	ldi	r18, 0x00	; 0
}
     f46:	82 2f       	mov	r24, r18
     f48:	08 95       	ret

00000f4a <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     f4a:	e1 ee       	ldi	r30, 0xE1	; 225
     f4c:	f4 e0       	ldi	r31, 0x04	; 4
     f4e:	13 82       	std	Z+3, r1	; 0x03
     f50:	12 82       	std	Z+2, r1	; 0x02
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
     f52:	88 ee       	ldi	r24, 0xE8	; 232
     f54:	93 e0       	ldi	r25, 0x03	; 3
     f56:	a0 e0       	ldi	r26, 0x00	; 0
     f58:	b0 e0       	ldi	r27, 0x00	; 0
     f5a:	84 83       	std	Z+4, r24	; 0x04
     f5c:	95 83       	std	Z+5, r25	; 0x05
     f5e:	a6 83       	std	Z+6, r26	; 0x06
     f60:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
     f62:	82 e2       	ldi	r24, 0x22	; 34
     f64:	91 e0       	ldi	r25, 0x01	; 1
     f66:	91 83       	std	Z+1, r25	; 0x01
     f68:	80 83       	st	Z, r24
     f6a:	85 ec       	ldi	r24, 0xC5	; 197
     f6c:	90 e0       	ldi	r25, 0x00	; 0
     f6e:	95 87       	std	Z+13, r25	; 0x0d
     f70:	84 87       	std	Z+12, r24	; 0x0c
     f72:	84 ec       	ldi	r24, 0xC4	; 196
     f74:	90 e0       	ldi	r25, 0x00	; 0
     f76:	97 87       	std	Z+15, r25	; 0x0f
     f78:	86 87       	std	Z+14, r24	; 0x0e
     f7a:	80 ec       	ldi	r24, 0xC0	; 192
     f7c:	90 e0       	ldi	r25, 0x00	; 0
     f7e:	91 8b       	std	Z+17, r25	; 0x11
     f80:	80 8b       	std	Z+16, r24	; 0x10
     f82:	81 ec       	ldi	r24, 0xC1	; 193
     f84:	90 e0       	ldi	r25, 0x00	; 0
     f86:	93 8b       	std	Z+19, r25	; 0x13
     f88:	82 8b       	std	Z+18, r24	; 0x12
     f8a:	82 ec       	ldi	r24, 0xC2	; 194
     f8c:	90 e0       	ldi	r25, 0x00	; 0
     f8e:	95 8b       	std	Z+21, r25	; 0x15
     f90:	84 8b       	std	Z+20, r24	; 0x14
     f92:	86 ec       	ldi	r24, 0xC6	; 198
     f94:	90 e0       	ldi	r25, 0x00	; 0
     f96:	97 8b       	std	Z+23, r25	; 0x17
     f98:	86 8b       	std	Z+22, r24	; 0x16
     f9a:	11 8e       	std	Z+25, r1	; 0x19
     f9c:	12 8e       	std	Z+26, r1	; 0x1a
     f9e:	13 8e       	std	Z+27, r1	; 0x1b
     fa0:	14 8e       	std	Z+28, r1	; 0x1c
     fa2:	08 95       	ret

00000fa4 <initVariant>:
int atexit(void (* /*func*/ )()) { return 0; }

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }
     fa4:	08 95       	ret

00000fa6 <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
     fa6:	0e 94 82 08 	call	0x1104	; 0x1104 <init>

	initVariant();
     faa:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
     fae:	0e 94 b2 00 	call	0x164	; 0x164 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
     fb2:	c6 e4       	ldi	r28, 0x46	; 70
     fb4:	d6 e0       	ldi	r29, 0x06	; 6
#endif
	
	setup();
    
	for (;;) {
		loop();
     fb6:	0e 94 f4 00 	call	0x1e8	; 0x1e8 <loop>
		if (serialEventRun) serialEventRun();
     fba:	20 97       	sbiw	r28, 0x00	; 0
     fbc:	e1 f3       	breq	.-8      	; 0xfb6 <main+0x10>
     fbe:	0e 94 46 06 	call	0xc8c	; 0xc8c <_Z14serialEventRunv>
     fc2:	f9 cf       	rjmp	.-14     	; 0xfb6 <main+0x10>

00000fc4 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     fc4:	cf 92       	push	r12
     fc6:	df 92       	push	r13
     fc8:	ef 92       	push	r14
     fca:	ff 92       	push	r15
     fcc:	0f 93       	push	r16
     fce:	1f 93       	push	r17
     fd0:	cf 93       	push	r28
     fd2:	df 93       	push	r29
     fd4:	6c 01       	movw	r12, r24
     fd6:	7a 01       	movw	r14, r20
     fd8:	8b 01       	movw	r16, r22
  size_t n = 0;
     fda:	c0 e0       	ldi	r28, 0x00	; 0
     fdc:	d0 e0       	ldi	r29, 0x00	; 0
  while (size--) {
     fde:	ce 15       	cp	r28, r14
     fe0:	df 05       	cpc	r29, r15
     fe2:	89 f0       	breq	.+34     	; 0x1006 <_ZN5Print5writeEPKhj+0x42>
    if (write(*buffer++)) n++;
     fe4:	d8 01       	movw	r26, r16
     fe6:	6d 91       	ld	r22, X+
     fe8:	8d 01       	movw	r16, r26
     fea:	d6 01       	movw	r26, r12
     fec:	ed 91       	ld	r30, X+
     fee:	fc 91       	ld	r31, X
     ff0:	01 90       	ld	r0, Z+
     ff2:	f0 81       	ld	r31, Z
     ff4:	e0 2d       	mov	r30, r0
     ff6:	c6 01       	movw	r24, r12
     ff8:	09 95       	icall
     ffa:	89 2b       	or	r24, r25
     ffc:	11 f4       	brne	.+4      	; 0x1002 <_ZN5Print5writeEPKhj+0x3e>
     ffe:	7e 01       	movw	r14, r28
    1000:	02 c0       	rjmp	.+4      	; 0x1006 <_ZN5Print5writeEPKhj+0x42>
    1002:	21 96       	adiw	r28, 0x01	; 1
    1004:	ec cf       	rjmp	.-40     	; 0xfde <_ZN5Print5writeEPKhj+0x1a>
    else break;
  }
  return n;
}
    1006:	c7 01       	movw	r24, r14
    1008:	df 91       	pop	r29
    100a:	cf 91       	pop	r28
    100c:	1f 91       	pop	r17
    100e:	0f 91       	pop	r16
    1010:	ff 90       	pop	r15
    1012:	ef 90       	pop	r14
    1014:	df 90       	pop	r13
    1016:	cf 90       	pop	r12
    1018:	08 95       	ret

0000101a <_ZN5Print5writeEPKc>:
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    101a:	61 15       	cp	r22, r1
    101c:	71 05       	cpc	r23, r1
    101e:	79 f0       	breq	.+30     	; 0x103e <_ZN5Print5writeEPKc+0x24>
      return write((const uint8_t *)str, strlen(str));
    1020:	fb 01       	movw	r30, r22
    1022:	01 90       	ld	r0, Z+
    1024:	00 20       	and	r0, r0
    1026:	e9 f7       	brne	.-6      	; 0x1022 <_ZN5Print5writeEPKc+0x8>
    1028:	31 97       	sbiw	r30, 0x01	; 1
    102a:	af 01       	movw	r20, r30
    102c:	46 1b       	sub	r20, r22
    102e:	57 0b       	sbc	r21, r23
    1030:	dc 01       	movw	r26, r24
    1032:	ed 91       	ld	r30, X+
    1034:	fc 91       	ld	r31, X
    1036:	02 80       	ldd	r0, Z+2	; 0x02
    1038:	f3 81       	ldd	r31, Z+3	; 0x03
    103a:	e0 2d       	mov	r30, r0
    103c:	09 94       	ijmp
    }
    103e:	80 e0       	ldi	r24, 0x00	; 0
    1040:	90 e0       	ldi	r25, 0x00	; 0
    1042:	08 95       	ret

00001044 <_ZN5Print7printlnEv>:
  return x.printTo(*this);
}

size_t Print::println(void)
{
  return write("\r\n");
    1044:	6d e0       	ldi	r22, 0x0D	; 13
    1046:	71 e0       	ldi	r23, 0x01	; 1
    1048:	0c 94 0d 08 	jmp	0x101a	; 0x101a <_ZN5Print5writeEPKc>

0000104c <_ZN5Print7printlnEPKc>:
  n += println();
  return n;
}

size_t Print::println(const char c[])
{
    104c:	0f 93       	push	r16
    104e:	1f 93       	push	r17
    1050:	cf 93       	push	r28
    1052:	df 93       	push	r29
    1054:	ec 01       	movw	r28, r24
  return write(s.c_str(), s.length());
}

size_t Print::print(const char str[])
{
  return write(str);
    1056:	0e 94 0d 08 	call	0x101a	; 0x101a <_ZN5Print5writeEPKc>
    105a:	8c 01       	movw	r16, r24
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
    105c:	ce 01       	movw	r24, r28
    105e:	0e 94 22 08 	call	0x1044	; 0x1044 <_ZN5Print7printlnEv>
  return n;
}
    1062:	80 0f       	add	r24, r16
    1064:	91 1f       	adc	r25, r17
    1066:	df 91       	pop	r29
    1068:	cf 91       	pop	r28
    106a:	1f 91       	pop	r17
    106c:	0f 91       	pop	r16
    106e:	08 95       	ret

00001070 <__vector_16>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
    1070:	1f 92       	push	r1
    1072:	0f 92       	push	r0
    1074:	0f b6       	in	r0, 0x3f	; 63
    1076:	0f 92       	push	r0
    1078:	11 24       	eor	r1, r1
    107a:	2f 93       	push	r18
    107c:	3f 93       	push	r19
    107e:	8f 93       	push	r24
    1080:	9f 93       	push	r25
    1082:	af 93       	push	r26
    1084:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
    1086:	80 91 7f 05 	lds	r24, 0x057F
    108a:	90 91 80 05 	lds	r25, 0x0580
    108e:	a0 91 81 05 	lds	r26, 0x0581
    1092:	b0 91 82 05 	lds	r27, 0x0582
	unsigned char f = timer0_fract;
    1096:	30 91 7e 05 	lds	r19, 0x057E

	m += MILLIS_INC;
	f += FRACT_INC;
    109a:	23 e0       	ldi	r18, 0x03	; 3
    109c:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
    109e:	2d 37       	cpi	r18, 0x7D	; 125
    10a0:	20 f4       	brcc	.+8      	; 0x10aa <__vector_16+0x3a>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
    10a2:	01 96       	adiw	r24, 0x01	; 1
    10a4:	a1 1d       	adc	r26, r1
    10a6:	b1 1d       	adc	r27, r1
    10a8:	05 c0       	rjmp	.+10     	; 0x10b4 <__vector_16+0x44>
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
    10aa:	26 e8       	ldi	r18, 0x86	; 134
    10ac:	23 0f       	add	r18, r19
		m += 1;
    10ae:	02 96       	adiw	r24, 0x02	; 2
    10b0:	a1 1d       	adc	r26, r1
    10b2:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
    10b4:	20 93 7e 05 	sts	0x057E, r18
	timer0_millis = m;
    10b8:	80 93 7f 05 	sts	0x057F, r24
    10bc:	90 93 80 05 	sts	0x0580, r25
    10c0:	a0 93 81 05 	sts	0x0581, r26
    10c4:	b0 93 82 05 	sts	0x0582, r27
	timer0_overflow_count++;
    10c8:	80 91 83 05 	lds	r24, 0x0583
    10cc:	90 91 84 05 	lds	r25, 0x0584
    10d0:	a0 91 85 05 	lds	r26, 0x0585
    10d4:	b0 91 86 05 	lds	r27, 0x0586
    10d8:	01 96       	adiw	r24, 0x01	; 1
    10da:	a1 1d       	adc	r26, r1
    10dc:	b1 1d       	adc	r27, r1
    10de:	80 93 83 05 	sts	0x0583, r24
    10e2:	90 93 84 05 	sts	0x0584, r25
    10e6:	a0 93 85 05 	sts	0x0585, r26
    10ea:	b0 93 86 05 	sts	0x0586, r27
}
    10ee:	bf 91       	pop	r27
    10f0:	af 91       	pop	r26
    10f2:	9f 91       	pop	r25
    10f4:	8f 91       	pop	r24
    10f6:	3f 91       	pop	r19
    10f8:	2f 91       	pop	r18
    10fa:	0f 90       	pop	r0
    10fc:	0f be       	out	0x3f, r0	; 63
    10fe:	0f 90       	pop	r0
    1100:	1f 90       	pop	r1
    1102:	18 95       	reti

00001104 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    1104:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    1106:	84 b5       	in	r24, 0x24	; 36
    1108:	82 60       	ori	r24, 0x02	; 2
    110a:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    110c:	84 b5       	in	r24, 0x24	; 36
    110e:	81 60       	ori	r24, 0x01	; 1
    1110:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    1112:	85 b5       	in	r24, 0x25	; 37
    1114:	82 60       	ori	r24, 0x02	; 2
    1116:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    1118:	85 b5       	in	r24, 0x25	; 37
    111a:	81 60       	ori	r24, 0x01	; 1
    111c:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    111e:	ee e6       	ldi	r30, 0x6E	; 110
    1120:	f0 e0       	ldi	r31, 0x00	; 0
    1122:	80 81       	ld	r24, Z
    1124:	81 60       	ori	r24, 0x01	; 1
    1126:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    1128:	e1 e8       	ldi	r30, 0x81	; 129
    112a:	f0 e0       	ldi	r31, 0x00	; 0
    112c:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    112e:	80 81       	ld	r24, Z
    1130:	82 60       	ori	r24, 0x02	; 2
    1132:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    1134:	80 81       	ld	r24, Z
    1136:	81 60       	ori	r24, 0x01	; 1
    1138:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    113a:	e0 e8       	ldi	r30, 0x80	; 128
    113c:	f0 e0       	ldi	r31, 0x00	; 0
    113e:	80 81       	ld	r24, Z
    1140:	81 60       	ori	r24, 0x01	; 1
    1142:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    1144:	e1 eb       	ldi	r30, 0xB1	; 177
    1146:	f0 e0       	ldi	r31, 0x00	; 0
    1148:	80 81       	ld	r24, Z
    114a:	84 60       	ori	r24, 0x04	; 4
    114c:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    114e:	e0 eb       	ldi	r30, 0xB0	; 176
    1150:	f0 e0       	ldi	r31, 0x00	; 0
    1152:	80 81       	ld	r24, Z
    1154:	81 60       	ori	r24, 0x01	; 1
    1156:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
    1158:	ea e7       	ldi	r30, 0x7A	; 122
    115a:	f0 e0       	ldi	r31, 0x00	; 0
    115c:	80 81       	ld	r24, Z
    115e:	84 60       	ori	r24, 0x04	; 4
    1160:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
    1162:	80 81       	ld	r24, Z
    1164:	82 60       	ori	r24, 0x02	; 2
    1166:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
    1168:	80 81       	ld	r24, Z
    116a:	81 60       	ori	r24, 0x01	; 1
    116c:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    116e:	80 81       	ld	r24, Z
    1170:	80 68       	ori	r24, 0x80	; 128
    1172:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    1174:	10 92 c1 00 	sts	0x00C1, r1
    1178:	08 95       	ret

0000117a <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    117a:	83 30       	cpi	r24, 0x03	; 3
    117c:	81 f0       	breq	.+32     	; 0x119e <turnOffPWM+0x24>
    117e:	28 f4       	brcc	.+10     	; 0x118a <turnOffPWM+0x10>
    1180:	81 30       	cpi	r24, 0x01	; 1
    1182:	99 f0       	breq	.+38     	; 0x11aa <turnOffPWM+0x30>
    1184:	82 30       	cpi	r24, 0x02	; 2
    1186:	a1 f0       	breq	.+40     	; 0x11b0 <turnOffPWM+0x36>
    1188:	08 95       	ret
    118a:	87 30       	cpi	r24, 0x07	; 7
    118c:	a9 f0       	breq	.+42     	; 0x11b8 <turnOffPWM+0x3e>
    118e:	88 30       	cpi	r24, 0x08	; 8
    1190:	b9 f0       	breq	.+46     	; 0x11c0 <turnOffPWM+0x46>
    1192:	84 30       	cpi	r24, 0x04	; 4
    1194:	d1 f4       	brne	.+52     	; 0x11ca <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    1196:	80 91 80 00 	lds	r24, 0x0080
    119a:	8f 7d       	andi	r24, 0xDF	; 223
    119c:	03 c0       	rjmp	.+6      	; 0x11a4 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    119e:	80 91 80 00 	lds	r24, 0x0080
    11a2:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    11a4:	80 93 80 00 	sts	0x0080, r24
    11a8:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    11aa:	84 b5       	in	r24, 0x24	; 36
    11ac:	8f 77       	andi	r24, 0x7F	; 127
    11ae:	02 c0       	rjmp	.+4      	; 0x11b4 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    11b0:	84 b5       	in	r24, 0x24	; 36
    11b2:	8f 7d       	andi	r24, 0xDF	; 223
    11b4:	84 bd       	out	0x24, r24	; 36
    11b6:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    11b8:	80 91 b0 00 	lds	r24, 0x00B0
    11bc:	8f 77       	andi	r24, 0x7F	; 127
    11be:	03 c0       	rjmp	.+6      	; 0x11c6 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    11c0:	80 91 b0 00 	lds	r24, 0x00B0
    11c4:	8f 7d       	andi	r24, 0xDF	; 223
    11c6:	80 93 b0 00 	sts	0x00B0, r24
    11ca:	08 95       	ret

000011cc <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    11cc:	cf 93       	push	r28
    11ce:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    11d0:	90 e0       	ldi	r25, 0x00	; 0
    11d2:	fc 01       	movw	r30, r24
    11d4:	e4 58       	subi	r30, 0x84	; 132
    11d6:	ff 4f       	sbci	r31, 0xFF	; 255
    11d8:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
    11da:	fc 01       	movw	r30, r24
    11dc:	e0 57       	subi	r30, 0x70	; 112
    11de:	ff 4f       	sbci	r31, 0xFF	; 255
    11e0:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    11e2:	88 23       	and	r24, r24
    11e4:	61 f1       	breq	.+88     	; 0x123e <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    11e6:	90 e0       	ldi	r25, 0x00	; 0
    11e8:	88 0f       	add	r24, r24
    11ea:	99 1f       	adc	r25, r25
    11ec:	fc 01       	movw	r30, r24
    11ee:	e2 55       	subi	r30, 0x52	; 82
    11f0:	ff 4f       	sbci	r31, 0xFF	; 255
    11f2:	c5 91       	lpm	r28, Z+
    11f4:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
    11f6:	fc 01       	movw	r30, r24
    11f8:	ec 55       	subi	r30, 0x5C	; 92
    11fa:	ff 4f       	sbci	r31, 0xFF	; 255
    11fc:	a5 91       	lpm	r26, Z+
    11fe:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
    1200:	61 11       	cpse	r22, r1
    1202:	09 c0       	rjmp	.+18     	; 0x1216 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
    1204:	9f b7       	in	r25, 0x3f	; 63
                cli();
    1206:	f8 94       	cli
		*reg &= ~bit;
    1208:	88 81       	ld	r24, Y
    120a:	20 95       	com	r18
    120c:	82 23       	and	r24, r18
    120e:	88 83       	st	Y, r24
		*out &= ~bit;
    1210:	ec 91       	ld	r30, X
    1212:	2e 23       	and	r18, r30
    1214:	0b c0       	rjmp	.+22     	; 0x122c <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    1216:	62 30       	cpi	r22, 0x02	; 2
    1218:	61 f4       	brne	.+24     	; 0x1232 <pinMode+0x66>
		uint8_t oldSREG = SREG;
    121a:	9f b7       	in	r25, 0x3f	; 63
                cli();
    121c:	f8 94       	cli
		*reg &= ~bit;
    121e:	38 81       	ld	r19, Y
    1220:	82 2f       	mov	r24, r18
    1222:	80 95       	com	r24
    1224:	83 23       	and	r24, r19
    1226:	88 83       	st	Y, r24
		*out |= bit;
    1228:	ec 91       	ld	r30, X
    122a:	2e 2b       	or	r18, r30
    122c:	2c 93       	st	X, r18
		SREG = oldSREG;
    122e:	9f bf       	out	0x3f, r25	; 63
    1230:	06 c0       	rjmp	.+12     	; 0x123e <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
    1232:	8f b7       	in	r24, 0x3f	; 63
                cli();
    1234:	f8 94       	cli
		*reg |= bit;
    1236:	e8 81       	ld	r30, Y
    1238:	2e 2b       	or	r18, r30
    123a:	28 83       	st	Y, r18
		SREG = oldSREG;
    123c:	8f bf       	out	0x3f, r24	; 63
	}
}
    123e:	df 91       	pop	r29
    1240:	cf 91       	pop	r28
    1242:	08 95       	ret

00001244 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
    1244:	1f 93       	push	r17
    1246:	cf 93       	push	r28
    1248:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
    124a:	28 2f       	mov	r18, r24
    124c:	30 e0       	ldi	r19, 0x00	; 0
    124e:	f9 01       	movw	r30, r18
    1250:	e8 59       	subi	r30, 0x98	; 152
    1252:	ff 4f       	sbci	r31, 0xFF	; 255
    1254:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
    1256:	f9 01       	movw	r30, r18
    1258:	e4 58       	subi	r30, 0x84	; 132
    125a:	ff 4f       	sbci	r31, 0xFF	; 255
    125c:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
    125e:	f9 01       	movw	r30, r18
    1260:	e0 57       	subi	r30, 0x70	; 112
    1262:	ff 4f       	sbci	r31, 0xFF	; 255
    1264:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    1266:	cc 23       	and	r28, r28
    1268:	c9 f0       	breq	.+50     	; 0x129c <digitalWrite+0x58>
    126a:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    126c:	81 11       	cpse	r24, r1
    126e:	0e 94 bd 08 	call	0x117a	; 0x117a <turnOffPWM>

	out = portOutputRegister(port);
    1272:	ec 2f       	mov	r30, r28
    1274:	f0 e0       	ldi	r31, 0x00	; 0
    1276:	ee 0f       	add	r30, r30
    1278:	ff 1f       	adc	r31, r31
    127a:	ec 55       	subi	r30, 0x5C	; 92
    127c:	ff 4f       	sbci	r31, 0xFF	; 255
    127e:	a5 91       	lpm	r26, Z+
    1280:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
    1282:	8f b7       	in	r24, 0x3f	; 63
	cli();
    1284:	f8 94       	cli

	if (val == LOW) {
    1286:	11 11       	cpse	r17, r1
    1288:	05 c0       	rjmp	.+10     	; 0x1294 <digitalWrite+0x50>
		*out &= ~bit;
    128a:	9c 91       	ld	r25, X
    128c:	ed 2f       	mov	r30, r29
    128e:	e0 95       	com	r30
    1290:	e9 23       	and	r30, r25
    1292:	02 c0       	rjmp	.+4      	; 0x1298 <digitalWrite+0x54>
	} else {
		*out |= bit;
    1294:	ec 91       	ld	r30, X
    1296:	ed 2b       	or	r30, r29
    1298:	ec 93       	st	X, r30
	}

	SREG = oldSREG;
    129a:	8f bf       	out	0x3f, r24	; 63
}
    129c:	df 91       	pop	r29
    129e:	cf 91       	pop	r28
    12a0:	1f 91       	pop	r17
    12a2:	08 95       	ret

000012a4 <__udivmodsi4>:
    12a4:	a1 e2       	ldi	r26, 0x21	; 33
    12a6:	1a 2e       	mov	r1, r26
    12a8:	aa 1b       	sub	r26, r26
    12aa:	bb 1b       	sub	r27, r27
    12ac:	fd 01       	movw	r30, r26
    12ae:	0d c0       	rjmp	.+26     	; 0x12ca <__udivmodsi4_ep>

000012b0 <__udivmodsi4_loop>:
    12b0:	aa 1f       	adc	r26, r26
    12b2:	bb 1f       	adc	r27, r27
    12b4:	ee 1f       	adc	r30, r30
    12b6:	ff 1f       	adc	r31, r31
    12b8:	a2 17       	cp	r26, r18
    12ba:	b3 07       	cpc	r27, r19
    12bc:	e4 07       	cpc	r30, r20
    12be:	f5 07       	cpc	r31, r21
    12c0:	20 f0       	brcs	.+8      	; 0x12ca <__udivmodsi4_ep>
    12c2:	a2 1b       	sub	r26, r18
    12c4:	b3 0b       	sbc	r27, r19
    12c6:	e4 0b       	sbc	r30, r20
    12c8:	f5 0b       	sbc	r31, r21

000012ca <__udivmodsi4_ep>:
    12ca:	66 1f       	adc	r22, r22
    12cc:	77 1f       	adc	r23, r23
    12ce:	88 1f       	adc	r24, r24
    12d0:	99 1f       	adc	r25, r25
    12d2:	1a 94       	dec	r1
    12d4:	69 f7       	brne	.-38     	; 0x12b0 <__udivmodsi4_loop>
    12d6:	60 95       	com	r22
    12d8:	70 95       	com	r23
    12da:	80 95       	com	r24
    12dc:	90 95       	com	r25
    12de:	9b 01       	movw	r18, r22
    12e0:	ac 01       	movw	r20, r24
    12e2:	bd 01       	movw	r22, r26
    12e4:	cf 01       	movw	r24, r30
    12e6:	08 95       	ret

000012e8 <__tablejump2__>:
    12e8:	ee 0f       	add	r30, r30
    12ea:	ff 1f       	adc	r31, r31
    12ec:	05 90       	lpm	r0, Z+
    12ee:	f4 91       	lpm	r31, Z
    12f0:	e0 2d       	mov	r30, r0
    12f2:	09 94       	ijmp

000012f4 <_exit>:
    12f4:	f8 94       	cli

000012f6 <__stop_program>:
    12f6:	ff cf       	rjmp	.-2      	; 0x12f6 <__stop_program>
