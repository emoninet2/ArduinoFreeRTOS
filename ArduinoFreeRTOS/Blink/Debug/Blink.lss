
Blink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  00000e52  00000ee6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000e52  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000003ae  00800110  00800110  00000ef6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000ef6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000f28  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000280  00000000  00000000  00000f68  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000028a2  00000000  00000000  000011e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000bde  00000000  00000000  00003a8a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000fa3  00000000  00000000  00004668  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000610  00000000  00000000  0000560c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e70  00000000  00000000  00005c1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001bea  00000000  00000000  00006a8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000230  00000000  00000000  00008676  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5c 00 	jmp	0xb8	; 0xb8 <__ctors_end>
   4:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
   8:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
   c:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  10:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  14:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  18:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  1c:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  20:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  24:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  28:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  2c:	0c 94 35 02 	jmp	0x46a	; 0x46a <__vector_11>
  30:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  34:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  38:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  3c:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  40:	0c 94 0d 06 	jmp	0xc1a	; 0xc1a <__vector_16>
  44:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  48:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  4c:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  50:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  54:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  58:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  5c:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  60:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>
  64:	0c 94 79 00 	jmp	0xf2	; 0xf2 <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	00 00       	nop
  6a:	00 08       	sbc	r0, r0
  6c:	00 02       	muls	r16, r16
  6e:	01 00       	.word	0x0001	; ????
  70:	00 03       	mulsu	r16, r16
  72:	04 07       	cpc	r16, r20
	...

0000007c <digital_pin_to_bit_mask_PGM>:
  7c:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
  8c:	04 08 10 20                                         ... 

00000090 <digital_pin_to_port_PGM>:
  90:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
  a0:	03 03 03 03                                         ....

000000a4 <port_to_output_PGM>:
  a4:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

000000ae <port_to_mode_PGM>:
  ae:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

000000b8 <__ctors_end>:
  b8:	11 24       	eor	r1, r1
  ba:	1f be       	out	0x3f, r1	; 63
  bc:	cf ef       	ldi	r28, 0xFF	; 255
  be:	d8 e0       	ldi	r29, 0x08	; 8
  c0:	de bf       	out	0x3e, r29	; 62
  c2:	cd bf       	out	0x3d, r28	; 61

000000c4 <__do_copy_data>:
  c4:	11 e0       	ldi	r17, 0x01	; 1
  c6:	a0 e0       	ldi	r26, 0x00	; 0
  c8:	b1 e0       	ldi	r27, 0x01	; 1
  ca:	e2 e5       	ldi	r30, 0x52	; 82
  cc:	fe e0       	ldi	r31, 0x0E	; 14
  ce:	02 c0       	rjmp	.+4      	; 0xd4 <__do_copy_data+0x10>
  d0:	05 90       	lpm	r0, Z+
  d2:	0d 92       	st	X+, r0
  d4:	a0 31       	cpi	r26, 0x10	; 16
  d6:	b1 07       	cpc	r27, r17
  d8:	d9 f7       	brne	.-10     	; 0xd0 <__do_copy_data+0xc>

000000da <__do_clear_bss>:
  da:	24 e0       	ldi	r18, 0x04	; 4
  dc:	a0 e1       	ldi	r26, 0x10	; 16
  de:	b1 e0       	ldi	r27, 0x01	; 1
  e0:	01 c0       	rjmp	.+2      	; 0xe4 <.do_clear_bss_start>

000000e2 <.do_clear_bss_loop>:
  e2:	1d 92       	st	X+, r1

000000e4 <.do_clear_bss_start>:
  e4:	ae 3b       	cpi	r26, 0xBE	; 190
  e6:	b2 07       	cpc	r27, r18
  e8:	e1 f7       	brne	.-8      	; 0xe2 <.do_clear_bss_loop>
  ea:	0e 94 fe 05 	call	0xbfc	; 0xbfc <main>
  ee:	0c 94 27 07 	jmp	0xe4e	; 0xe4e <_exit>

000000f2 <__bad_interrupt>:
  f2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000f6 <_Z8thread_1Pv>:
  by Scott Fitzgerald
 */

void thread_1( void *pvParameters ){
	while(1){
		digitalWrite(13, HIGH);   // turn the LED on (HIGH is the voltage level)
  f6:	61 e0       	ldi	r22, 0x01	; 1
  f8:	8d e0       	ldi	r24, 0x0D	; 13
  fa:	0e 94 f7 06 	call	0xdee	; 0xdee <digitalWrite>
		vTaskDelay(500);              // wait for a second
  fe:	84 ef       	ldi	r24, 0xF4	; 244
 100:	91 e0       	ldi	r25, 0x01	; 1
 102:	0e 94 90 05 	call	0xb20	; 0xb20 <vTaskDelay>
		digitalWrite(13, LOW);    // turn the LED off by making the voltage LOW
 106:	60 e0       	ldi	r22, 0x00	; 0
 108:	8d e0       	ldi	r24, 0x0D	; 13
 10a:	0e 94 f7 06 	call	0xdee	; 0xdee <digitalWrite>
		vTaskDelay(500);              // wait for a second
 10e:	84 ef       	ldi	r24, 0xF4	; 244
 110:	91 e0       	ldi	r25, 0x01	; 1
 112:	0e 94 90 05 	call	0xb20	; 0xb20 <vTaskDelay>

  modified 8 May 2014
  by Scott Fitzgerald
 */

void thread_1( void *pvParameters ){
 116:	ef cf       	rjmp	.-34     	; 0xf6 <_Z8thread_1Pv>

00000118 <_Z8thread_2Pv>:
	}

}

void thread_2( void *pvParameters ){
	DDRB |= (1<<DDB0);
 118:	20 9a       	sbi	0x04, 0	; 4
	while(1){
		PORTB ^= (1<<PORTB0);
 11a:	c1 e0       	ldi	r28, 0x01	; 1
 11c:	85 b1       	in	r24, 0x05	; 5
 11e:	8c 27       	eor	r24, r28
 120:	85 b9       	out	0x05, r24	; 5
		vTaskDelay(2000);
 122:	80 ed       	ldi	r24, 0xD0	; 208
 124:	97 e0       	ldi	r25, 0x07	; 7
 126:	0e 94 90 05 	call	0xb20	; 0xb20 <vTaskDelay>
		vTaskDelay(500);              // wait for a second
	}

}

void thread_2( void *pvParameters ){
 12a:	f8 cf       	rjmp	.-16     	; 0x11c <_Z8thread_2Pv+0x4>

0000012c <_Z8thread_3Pv>:
		vTaskDelay(2000);
	}
}

void thread_3( void *pvParameters ){
	DDRB |= (1<<DDB1);
 12c:	21 9a       	sbi	0x04, 1	; 4
	while(1){
		PORTB ^= (1<<PORTB1);
 12e:	c2 e0       	ldi	r28, 0x02	; 2
 130:	85 b1       	in	r24, 0x05	; 5
 132:	8c 27       	eor	r24, r28
 134:	85 b9       	out	0x05, r24	; 5
		vTaskDelay(200);
 136:	88 ec       	ldi	r24, 0xC8	; 200
 138:	90 e0       	ldi	r25, 0x00	; 0
 13a:	0e 94 90 05 	call	0xb20	; 0xb20 <vTaskDelay>
		PORTB ^= (1<<PORTB0);
		vTaskDelay(2000);
	}
}

void thread_3( void *pvParameters ){
 13e:	f8 cf       	rjmp	.-16     	; 0x130 <_Z8thread_3Pv+0x4>

00000140 <setup>:
}



// the setup function runs once when you press reset or power the board
void setup() {
 140:	af 92       	push	r10
 142:	bf 92       	push	r11
 144:	cf 92       	push	r12
 146:	df 92       	push	r13
 148:	ef 92       	push	r14
 14a:	ff 92       	push	r15
 14c:	0f 93       	push	r16
  // initialize digital pin 13 as an output.
  pinMode(13, OUTPUT);
 14e:	61 e0       	ldi	r22, 0x01	; 1
 150:	8d e0       	ldi	r24, 0x0D	; 13
 152:	0e 94 bb 06 	call	0xd76	; 0xd76 <pinMode>
  
  	//creating the threads
	xTaskCreate( thread_1, ( const char * ) "t1", 300, NULL, tskIDLE_PRIORITY, NULL );
 156:	a1 2c       	mov	r10, r1
 158:	b1 2c       	mov	r11, r1
 15a:	c1 2c       	mov	r12, r1
 15c:	d1 2c       	mov	r13, r1
 15e:	e1 2c       	mov	r14, r1
 160:	f1 2c       	mov	r15, r1
 162:	00 e0       	ldi	r16, 0x00	; 0
 164:	20 e0       	ldi	r18, 0x00	; 0
 166:	30 e0       	ldi	r19, 0x00	; 0
 168:	4c e2       	ldi	r20, 0x2C	; 44
 16a:	51 e0       	ldi	r21, 0x01	; 1
 16c:	62 e0       	ldi	r22, 0x02	; 2
 16e:	71 e0       	ldi	r23, 0x01	; 1
 170:	8b e7       	ldi	r24, 0x7B	; 123
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	0e 94 32 03 	call	0x664	; 0x664 <xTaskGenericCreate>
	xTaskCreate( thread_2, ( const char * ) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
 178:	20 e0       	ldi	r18, 0x00	; 0
 17a:	30 e0       	ldi	r19, 0x00	; 0
 17c:	44 e6       	ldi	r20, 0x64	; 100
 17e:	50 e0       	ldi	r21, 0x00	; 0
 180:	65 e0       	ldi	r22, 0x05	; 5
 182:	71 e0       	ldi	r23, 0x01	; 1
 184:	8c e8       	ldi	r24, 0x8C	; 140
 186:	90 e0       	ldi	r25, 0x00	; 0
 188:	0e 94 32 03 	call	0x664	; 0x664 <xTaskGenericCreate>
	xTaskCreate( thread_3, ( const char * ) "t3", 100, NULL, tskIDLE_PRIORITY, NULL );
 18c:	20 e0       	ldi	r18, 0x00	; 0
 18e:	30 e0       	ldi	r19, 0x00	; 0
 190:	44 e6       	ldi	r20, 0x64	; 100
 192:	50 e0       	ldi	r21, 0x00	; 0
 194:	68 e0       	ldi	r22, 0x08	; 8
 196:	71 e0       	ldi	r23, 0x01	; 1
 198:	86 e9       	ldi	r24, 0x96	; 150
 19a:	90 e0       	ldi	r25, 0x00	; 0
 19c:	0e 94 32 03 	call	0x664	; 0x664 <xTaskGenericCreate>
  
	//starting the scheduler
	vTaskStartScheduler();
}
 1a0:	0f 91       	pop	r16
 1a2:	ff 90       	pop	r15
 1a4:	ef 90       	pop	r14
 1a6:	df 90       	pop	r13
 1a8:	cf 90       	pop	r12
 1aa:	bf 90       	pop	r11
 1ac:	af 90       	pop	r10
	xTaskCreate( thread_1, ( const char * ) "t1", 300, NULL, tskIDLE_PRIORITY, NULL );
	xTaskCreate( thread_2, ( const char * ) "t2", 100, NULL, tskIDLE_PRIORITY, NULL );
	xTaskCreate( thread_3, ( const char * ) "t3", 100, NULL, tskIDLE_PRIORITY, NULL );
  
	//starting the scheduler
	vTaskStartScheduler();
 1ae:	0c 94 21 04 	jmp	0x842	; 0x842 <vTaskStartScheduler>

000001b2 <loop>:
}

// the loop function runs over and over again forever
void loop() {
 1b2:	08 95       	ret

000001b4 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
 1b4:	31 e1       	ldi	r19, 0x11	; 17
 1b6:	fc 01       	movw	r30, r24
 1b8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
 1ba:	31 97       	sbiw	r30, 0x01	; 1
 1bc:	22 e2       	ldi	r18, 0x22	; 34
 1be:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
 1c0:	31 97       	sbiw	r30, 0x01	; 1
 1c2:	a3 e3       	ldi	r26, 0x33	; 51
 1c4:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 1c6:	31 97       	sbiw	r30, 0x01	; 1
 1c8:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 1ca:	31 97       	sbiw	r30, 0x01	; 1
 1cc:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
 1ce:	31 97       	sbiw	r30, 0x01	; 1
 1d0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
 1d2:	31 97       	sbiw	r30, 0x01	; 1
 1d4:	60 e8       	ldi	r22, 0x80	; 128
 1d6:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
 1d8:	31 97       	sbiw	r30, 0x01	; 1
 1da:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
 1dc:	31 97       	sbiw	r30, 0x01	; 1
 1de:	62 e0       	ldi	r22, 0x02	; 2
 1e0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
 1e2:	31 97       	sbiw	r30, 0x01	; 1
 1e4:	63 e0       	ldi	r22, 0x03	; 3
 1e6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
 1e8:	31 97       	sbiw	r30, 0x01	; 1
 1ea:	64 e0       	ldi	r22, 0x04	; 4
 1ec:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
 1ee:	31 97       	sbiw	r30, 0x01	; 1
 1f0:	65 e0       	ldi	r22, 0x05	; 5
 1f2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
 1f4:	31 97       	sbiw	r30, 0x01	; 1
 1f6:	66 e0       	ldi	r22, 0x06	; 6
 1f8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
 1fa:	31 97       	sbiw	r30, 0x01	; 1
 1fc:	67 e0       	ldi	r22, 0x07	; 7
 1fe:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
 200:	31 97       	sbiw	r30, 0x01	; 1
 202:	68 e0       	ldi	r22, 0x08	; 8
 204:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
 206:	31 97       	sbiw	r30, 0x01	; 1
 208:	69 e0       	ldi	r22, 0x09	; 9
 20a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
 20c:	31 97       	sbiw	r30, 0x01	; 1
 20e:	60 e1       	ldi	r22, 0x10	; 16
 210:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
 212:	31 97       	sbiw	r30, 0x01	; 1
 214:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
 216:	31 97       	sbiw	r30, 0x01	; 1
 218:	32 e1       	ldi	r19, 0x12	; 18
 21a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
 21c:	31 97       	sbiw	r30, 0x01	; 1
 21e:	33 e1       	ldi	r19, 0x13	; 19
 220:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
 222:	31 97       	sbiw	r30, 0x01	; 1
 224:	34 e1       	ldi	r19, 0x14	; 20
 226:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
 228:	31 97       	sbiw	r30, 0x01	; 1
 22a:	35 e1       	ldi	r19, 0x15	; 21
 22c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
 22e:	31 97       	sbiw	r30, 0x01	; 1
 230:	36 e1       	ldi	r19, 0x16	; 22
 232:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
 234:	31 97       	sbiw	r30, 0x01	; 1
 236:	37 e1       	ldi	r19, 0x17	; 23
 238:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
 23a:	31 97       	sbiw	r30, 0x01	; 1
 23c:	38 e1       	ldi	r19, 0x18	; 24
 23e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
 240:	31 97       	sbiw	r30, 0x01	; 1
 242:	39 e1       	ldi	r19, 0x19	; 25
 244:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
 246:	31 97       	sbiw	r30, 0x01	; 1
 248:	30 e2       	ldi	r19, 0x20	; 32
 24a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
 24c:	31 97       	sbiw	r30, 0x01	; 1
 24e:	31 e2       	ldi	r19, 0x21	; 33
 250:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
 252:	31 97       	sbiw	r30, 0x01	; 1
 254:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
 256:	31 97       	sbiw	r30, 0x01	; 1
 258:	23 e2       	ldi	r18, 0x23	; 35
 25a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 25c:	31 97       	sbiw	r30, 0x01	; 1
 25e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 260:	31 97       	sbiw	r30, 0x01	; 1
 262:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
 264:	31 97       	sbiw	r30, 0x01	; 1
 266:	26 e2       	ldi	r18, 0x26	; 38
 268:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
 26a:	31 97       	sbiw	r30, 0x01	; 1
 26c:	27 e2       	ldi	r18, 0x27	; 39
 26e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
 270:	31 97       	sbiw	r30, 0x01	; 1
 272:	28 e2       	ldi	r18, 0x28	; 40
 274:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
 276:	31 97       	sbiw	r30, 0x01	; 1
 278:	29 e2       	ldi	r18, 0x29	; 41
 27a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
 27c:	31 97       	sbiw	r30, 0x01	; 1
 27e:	20 e3       	ldi	r18, 0x30	; 48
 280:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
 282:	31 97       	sbiw	r30, 0x01	; 1
 284:	21 e3       	ldi	r18, 0x31	; 49
 286:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
 288:	86 97       	sbiw	r24, 0x26	; 38
 28a:	08 95       	ret

0000028c <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
 28c:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
 290:	8c e7       	ldi	r24, 0x7C	; 124
 292:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
 296:	8b e0       	ldi	r24, 0x0B	; 11
 298:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
 29c:	ef e6       	ldi	r30, 0x6F	; 111
 29e:	f0 e0       	ldi	r31, 0x00	; 0
 2a0:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
 2a2:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
 2a4:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
 2a6:	a0 91 b3 04 	lds	r26, 0x04B3
 2aa:	b0 91 b4 04 	lds	r27, 0x04B4
 2ae:	cd 91       	ld	r28, X+
 2b0:	cd bf       	out	0x3d, r28	; 61
 2b2:	dd 91       	ld	r29, X+
 2b4:	de bf       	out	0x3e, r29	; 62
 2b6:	ff 91       	pop	r31
 2b8:	ef 91       	pop	r30
 2ba:	df 91       	pop	r29
 2bc:	cf 91       	pop	r28
 2be:	bf 91       	pop	r27
 2c0:	af 91       	pop	r26
 2c2:	9f 91       	pop	r25
 2c4:	8f 91       	pop	r24
 2c6:	7f 91       	pop	r23
 2c8:	6f 91       	pop	r22
 2ca:	5f 91       	pop	r21
 2cc:	4f 91       	pop	r20
 2ce:	3f 91       	pop	r19
 2d0:	2f 91       	pop	r18
 2d2:	1f 91       	pop	r17
 2d4:	0f 91       	pop	r16
 2d6:	ff 90       	pop	r15
 2d8:	ef 90       	pop	r14
 2da:	df 90       	pop	r13
 2dc:	cf 90       	pop	r12
 2de:	bf 90       	pop	r11
 2e0:	af 90       	pop	r10
 2e2:	9f 90       	pop	r9
 2e4:	8f 90       	pop	r8
 2e6:	7f 90       	pop	r7
 2e8:	6f 90       	pop	r6
 2ea:	5f 90       	pop	r5
 2ec:	4f 90       	pop	r4
 2ee:	3f 90       	pop	r3
 2f0:	2f 90       	pop	r2
 2f2:	1f 90       	pop	r1
 2f4:	0f 90       	pop	r0
 2f6:	0f be       	out	0x3f, r0	; 63
 2f8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
 2fa:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
 2fc:	81 e0       	ldi	r24, 0x01	; 1
 2fe:	08 95       	ret

00000300 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 300:	0f 92       	push	r0
 302:	0f b6       	in	r0, 0x3f	; 63
 304:	f8 94       	cli
 306:	0f 92       	push	r0
 308:	1f 92       	push	r1
 30a:	11 24       	eor	r1, r1
 30c:	2f 92       	push	r2
 30e:	3f 92       	push	r3
 310:	4f 92       	push	r4
 312:	5f 92       	push	r5
 314:	6f 92       	push	r6
 316:	7f 92       	push	r7
 318:	8f 92       	push	r8
 31a:	9f 92       	push	r9
 31c:	af 92       	push	r10
 31e:	bf 92       	push	r11
 320:	cf 92       	push	r12
 322:	df 92       	push	r13
 324:	ef 92       	push	r14
 326:	ff 92       	push	r15
 328:	0f 93       	push	r16
 32a:	1f 93       	push	r17
 32c:	2f 93       	push	r18
 32e:	3f 93       	push	r19
 330:	4f 93       	push	r20
 332:	5f 93       	push	r21
 334:	6f 93       	push	r22
 336:	7f 93       	push	r23
 338:	8f 93       	push	r24
 33a:	9f 93       	push	r25
 33c:	af 93       	push	r26
 33e:	bf 93       	push	r27
 340:	cf 93       	push	r28
 342:	df 93       	push	r29
 344:	ef 93       	push	r30
 346:	ff 93       	push	r31
 348:	a0 91 b3 04 	lds	r26, 0x04B3
 34c:	b0 91 b4 04 	lds	r27, 0x04B4
 350:	0d b6       	in	r0, 0x3d	; 61
 352:	0d 92       	st	X+, r0
 354:	0e b6       	in	r0, 0x3e	; 62
 356:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 358:	0e 94 b1 05 	call	0xb62	; 0xb62 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 35c:	a0 91 b3 04 	lds	r26, 0x04B3
 360:	b0 91 b4 04 	lds	r27, 0x04B4
 364:	cd 91       	ld	r28, X+
 366:	cd bf       	out	0x3d, r28	; 61
 368:	dd 91       	ld	r29, X+
 36a:	de bf       	out	0x3e, r29	; 62
 36c:	ff 91       	pop	r31
 36e:	ef 91       	pop	r30
 370:	df 91       	pop	r29
 372:	cf 91       	pop	r28
 374:	bf 91       	pop	r27
 376:	af 91       	pop	r26
 378:	9f 91       	pop	r25
 37a:	8f 91       	pop	r24
 37c:	7f 91       	pop	r23
 37e:	6f 91       	pop	r22
 380:	5f 91       	pop	r21
 382:	4f 91       	pop	r20
 384:	3f 91       	pop	r19
 386:	2f 91       	pop	r18
 388:	1f 91       	pop	r17
 38a:	0f 91       	pop	r16
 38c:	ff 90       	pop	r15
 38e:	ef 90       	pop	r14
 390:	df 90       	pop	r13
 392:	cf 90       	pop	r12
 394:	bf 90       	pop	r11
 396:	af 90       	pop	r10
 398:	9f 90       	pop	r9
 39a:	8f 90       	pop	r8
 39c:	7f 90       	pop	r7
 39e:	6f 90       	pop	r6
 3a0:	5f 90       	pop	r5
 3a2:	4f 90       	pop	r4
 3a4:	3f 90       	pop	r3
 3a6:	2f 90       	pop	r2
 3a8:	1f 90       	pop	r1
 3aa:	0f 90       	pop	r0
 3ac:	0f be       	out	0x3f, r0	; 63
 3ae:	0f 90       	pop	r0

	asm volatile ( "ret" );
 3b0:	08 95       	ret

000003b2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 3b2:	0f 92       	push	r0
 3b4:	0f b6       	in	r0, 0x3f	; 63
 3b6:	f8 94       	cli
 3b8:	0f 92       	push	r0
 3ba:	1f 92       	push	r1
 3bc:	11 24       	eor	r1, r1
 3be:	2f 92       	push	r2
 3c0:	3f 92       	push	r3
 3c2:	4f 92       	push	r4
 3c4:	5f 92       	push	r5
 3c6:	6f 92       	push	r6
 3c8:	7f 92       	push	r7
 3ca:	8f 92       	push	r8
 3cc:	9f 92       	push	r9
 3ce:	af 92       	push	r10
 3d0:	bf 92       	push	r11
 3d2:	cf 92       	push	r12
 3d4:	df 92       	push	r13
 3d6:	ef 92       	push	r14
 3d8:	ff 92       	push	r15
 3da:	0f 93       	push	r16
 3dc:	1f 93       	push	r17
 3de:	2f 93       	push	r18
 3e0:	3f 93       	push	r19
 3e2:	4f 93       	push	r20
 3e4:	5f 93       	push	r21
 3e6:	6f 93       	push	r22
 3e8:	7f 93       	push	r23
 3ea:	8f 93       	push	r24
 3ec:	9f 93       	push	r25
 3ee:	af 93       	push	r26
 3f0:	bf 93       	push	r27
 3f2:	cf 93       	push	r28
 3f4:	df 93       	push	r29
 3f6:	ef 93       	push	r30
 3f8:	ff 93       	push	r31
 3fa:	a0 91 b3 04 	lds	r26, 0x04B3
 3fe:	b0 91 b4 04 	lds	r27, 0x04B4
 402:	0d b6       	in	r0, 0x3d	; 61
 404:	0d 92       	st	X+, r0
 406:	0e b6       	in	r0, 0x3e	; 62
 408:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 40a:	0e 94 59 04 	call	0x8b2	; 0x8b2 <xTaskIncrementTick>
 40e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 410:	0e 94 b1 05 	call	0xb62	; 0xb62 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 414:	a0 91 b3 04 	lds	r26, 0x04B3
 418:	b0 91 b4 04 	lds	r27, 0x04B4
 41c:	cd 91       	ld	r28, X+
 41e:	cd bf       	out	0x3d, r28	; 61
 420:	dd 91       	ld	r29, X+
 422:	de bf       	out	0x3e, r29	; 62
 424:	ff 91       	pop	r31
 426:	ef 91       	pop	r30
 428:	df 91       	pop	r29
 42a:	cf 91       	pop	r28
 42c:	bf 91       	pop	r27
 42e:	af 91       	pop	r26
 430:	9f 91       	pop	r25
 432:	8f 91       	pop	r24
 434:	7f 91       	pop	r23
 436:	6f 91       	pop	r22
 438:	5f 91       	pop	r21
 43a:	4f 91       	pop	r20
 43c:	3f 91       	pop	r19
 43e:	2f 91       	pop	r18
 440:	1f 91       	pop	r17
 442:	0f 91       	pop	r16
 444:	ff 90       	pop	r15
 446:	ef 90       	pop	r14
 448:	df 90       	pop	r13
 44a:	cf 90       	pop	r12
 44c:	bf 90       	pop	r11
 44e:	af 90       	pop	r10
 450:	9f 90       	pop	r9
 452:	8f 90       	pop	r8
 454:	7f 90       	pop	r7
 456:	6f 90       	pop	r6
 458:	5f 90       	pop	r5
 45a:	4f 90       	pop	r4
 45c:	3f 90       	pop	r3
 45e:	2f 90       	pop	r2
 460:	1f 90       	pop	r1
 462:	0f 90       	pop	r0
 464:	0f be       	out	0x3f, r0	; 63
 466:	0f 90       	pop	r0

	asm volatile ( "ret" );
 468:	08 95       	ret

0000046a <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 46a:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <vPortYieldFromTick>
		asm volatile ( "reti" );
 46e:	18 95       	reti

00000470 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 470:	cf 93       	push	r28
 472:	df 93       	push	r29
 474:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
 476:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 47a:	80 91 10 01 	lds	r24, 0x0110
 47e:	90 91 11 01 	lds	r25, 0x0111
 482:	89 2b       	or	r24, r25
 484:	31 f4       	brne	.+12     	; 0x492 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 486:	85 e1       	ldi	r24, 0x15	; 21
 488:	91 e0       	ldi	r25, 0x01	; 1
 48a:	90 93 11 01 	sts	0x0111, r25
 48e:	80 93 10 01 	sts	0x0110, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 492:	20 91 12 01 	lds	r18, 0x0112
 496:	30 91 13 01 	lds	r19, 0x0113
 49a:	ce 01       	movw	r24, r28
 49c:	82 0f       	add	r24, r18
 49e:	93 1f       	adc	r25, r19
 4a0:	81 35       	cpi	r24, 0x51	; 81
 4a2:	43 e0       	ldi	r20, 0x03	; 3
 4a4:	94 07       	cpc	r25, r20
 4a6:	70 f4       	brcc	.+28     	; 0x4c4 <pvPortMalloc+0x54>
 4a8:	28 17       	cp	r18, r24
 4aa:	39 07       	cpc	r19, r25
 4ac:	58 f4       	brcc	.+22     	; 0x4c4 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 4ae:	c0 91 10 01 	lds	r28, 0x0110
 4b2:	d0 91 11 01 	lds	r29, 0x0111
 4b6:	c2 0f       	add	r28, r18
 4b8:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 4ba:	90 93 13 01 	sts	0x0113, r25
 4be:	80 93 12 01 	sts	0x0112, r24
 4c2:	02 c0       	rjmp	.+4      	; 0x4c8 <pvPortMalloc+0x58>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 4c4:	c0 e0       	ldi	r28, 0x00	; 0
 4c6:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 4c8:	0e 94 20 05 	call	0xa40	; 0xa40 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 4cc:	ce 01       	movw	r24, r28
 4ce:	df 91       	pop	r29
 4d0:	cf 91       	pop	r28
 4d2:	08 95       	ret

000004d4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 4d4:	08 95       	ret

000004d6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 4d6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4d8:	03 96       	adiw	r24, 0x03	; 3
 4da:	92 83       	std	Z+2, r25	; 0x02
 4dc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 4de:	2f ef       	ldi	r18, 0xFF	; 255
 4e0:	3f ef       	ldi	r19, 0xFF	; 255
 4e2:	34 83       	std	Z+4, r19	; 0x04
 4e4:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4e6:	96 83       	std	Z+6, r25	; 0x06
 4e8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 4ea:	90 87       	std	Z+8, r25	; 0x08
 4ec:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 4ee:	10 82       	st	Z, r1
 4f0:	08 95       	ret

000004f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 4f2:	fc 01       	movw	r30, r24
 4f4:	11 86       	std	Z+9, r1	; 0x09
 4f6:	10 86       	std	Z+8, r1	; 0x08
 4f8:	08 95       	ret

000004fa <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 4fa:	cf 93       	push	r28
 4fc:	df 93       	push	r29
 4fe:	9c 01       	movw	r18, r24
 500:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 502:	dc 01       	movw	r26, r24
 504:	11 96       	adiw	r26, 0x01	; 1
 506:	cd 91       	ld	r28, X+
 508:	dc 91       	ld	r29, X
 50a:	12 97       	sbiw	r26, 0x02	; 2

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 50c:	d3 83       	std	Z+3, r29	; 0x03
 50e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 510:	8c 81       	ldd	r24, Y+4	; 0x04
 512:	9d 81       	ldd	r25, Y+5	; 0x05
 514:	95 83       	std	Z+5, r25	; 0x05
 516:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 518:	8c 81       	ldd	r24, Y+4	; 0x04
 51a:	9d 81       	ldd	r25, Y+5	; 0x05
 51c:	dc 01       	movw	r26, r24
 51e:	13 96       	adiw	r26, 0x03	; 3
 520:	7c 93       	st	X, r23
 522:	6e 93       	st	-X, r22
 524:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 526:	7d 83       	std	Y+5, r23	; 0x05
 528:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 52a:	31 87       	std	Z+9, r19	; 0x09
 52c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 52e:	f9 01       	movw	r30, r18
 530:	80 81       	ld	r24, Z
 532:	8f 5f       	subi	r24, 0xFF	; 255
 534:	80 83       	st	Z, r24
}
 536:	df 91       	pop	r29
 538:	cf 91       	pop	r28
 53a:	08 95       	ret

0000053c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 53c:	0f 93       	push	r16
 53e:	1f 93       	push	r17
 540:	cf 93       	push	r28
 542:	df 93       	push	r29
 544:	8c 01       	movw	r16, r24
 546:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 548:	80 81       	ld	r24, Z
 54a:	91 81       	ldd	r25, Z+1	; 0x01
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 54c:	8f 3f       	cpi	r24, 0xFF	; 255
 54e:	2f ef       	ldi	r18, 0xFF	; 255
 550:	92 07       	cpc	r25, r18
 552:	21 f4       	brne	.+8      	; 0x55c <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 554:	e8 01       	movw	r28, r16
 556:	af 81       	ldd	r26, Y+7	; 0x07
 558:	b8 85       	ldd	r27, Y+8	; 0x08
 55a:	0e c0       	rjmp	.+28     	; 0x578 <vListInsert+0x3c>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 55c:	d8 01       	movw	r26, r16
 55e:	13 96       	adiw	r26, 0x03	; 3
 560:	12 96       	adiw	r26, 0x02	; 2
 562:	2d 91       	ld	r18, X+
 564:	3c 91       	ld	r19, X
 566:	13 97       	sbiw	r26, 0x03	; 3
 568:	e9 01       	movw	r28, r18
 56a:	48 81       	ld	r20, Y
 56c:	59 81       	ldd	r21, Y+1	; 0x01
 56e:	84 17       	cp	r24, r20
 570:	95 07       	cpc	r25, r21
 572:	10 f0       	brcs	.+4      	; 0x578 <vListInsert+0x3c>
 574:	d9 01       	movw	r26, r18
 576:	f4 cf       	rjmp	.-24     	; 0x560 <vListInsert+0x24>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 578:	12 96       	adiw	r26, 0x02	; 2
 57a:	8d 91       	ld	r24, X+
 57c:	9c 91       	ld	r25, X
 57e:	13 97       	sbiw	r26, 0x03	; 3
 580:	93 83       	std	Z+3, r25	; 0x03
 582:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 584:	ec 01       	movw	r28, r24
 586:	fd 83       	std	Y+5, r31	; 0x05
 588:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 58a:	b5 83       	std	Z+5, r27	; 0x05
 58c:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 58e:	13 96       	adiw	r26, 0x03	; 3
 590:	fc 93       	st	X, r31
 592:	ee 93       	st	-X, r30
 594:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 596:	11 87       	std	Z+9, r17	; 0x09
 598:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
 59a:	f8 01       	movw	r30, r16
 59c:	80 81       	ld	r24, Z
 59e:	8f 5f       	subi	r24, 0xFF	; 255
 5a0:	80 83       	st	Z, r24
}
 5a2:	df 91       	pop	r29
 5a4:	cf 91       	pop	r28
 5a6:	1f 91       	pop	r17
 5a8:	0f 91       	pop	r16
 5aa:	08 95       	ret

000005ac <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 5ac:	cf 93       	push	r28
 5ae:	df 93       	push	r29
 5b0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 5b2:	a0 85       	ldd	r26, Z+8	; 0x08
 5b4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 5b6:	82 81       	ldd	r24, Z+2	; 0x02
 5b8:	93 81       	ldd	r25, Z+3	; 0x03
 5ba:	24 81       	ldd	r18, Z+4	; 0x04
 5bc:	35 81       	ldd	r19, Z+5	; 0x05
 5be:	ec 01       	movw	r28, r24
 5c0:	3d 83       	std	Y+5, r19	; 0x05
 5c2:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 5c4:	c4 81       	ldd	r28, Z+4	; 0x04
 5c6:	d5 81       	ldd	r29, Z+5	; 0x05
 5c8:	9b 83       	std	Y+3, r25	; 0x03
 5ca:	8a 83       	std	Y+2, r24	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 5cc:	11 96       	adiw	r26, 0x01	; 1
 5ce:	8d 91       	ld	r24, X+
 5d0:	9c 91       	ld	r25, X
 5d2:	12 97       	sbiw	r26, 0x02	; 2
 5d4:	8e 17       	cp	r24, r30
 5d6:	9f 07       	cpc	r25, r31
 5d8:	21 f4       	brne	.+8      	; 0x5e2 <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 5da:	12 96       	adiw	r26, 0x02	; 2
 5dc:	dc 93       	st	X, r29
 5de:	ce 93       	st	-X, r28
 5e0:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 5e2:	11 86       	std	Z+9, r1	; 0x09
 5e4:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 5e6:	8c 91       	ld	r24, X
 5e8:	81 50       	subi	r24, 0x01	; 1
 5ea:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 5ec:	df 91       	pop	r29
 5ee:	cf 91       	pop	r28
 5f0:	08 95       	ret

000005f2 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 5f2:	ff cf       	rjmp	.-2      	; 0x5f2 <prvIdleTask>

000005f4 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 5f4:	cf 93       	push	r28
 5f6:	df 93       	push	r29
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 5f8:	e0 91 b3 04 	lds	r30, 0x04B3
 5fc:	f0 91 b4 04 	lds	r31, 0x04B4
 600:	93 83       	std	Z+3, r25	; 0x03
 602:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
 604:	20 91 6d 04 	lds	r18, 0x046D
 608:	30 91 6e 04 	lds	r19, 0x046E
 60c:	82 17       	cp	r24, r18
 60e:	93 07       	cpc	r25, r19
 610:	70 f4       	brcc	.+28     	; 0x62e <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 612:	60 91 b3 04 	lds	r22, 0x04B3
 616:	70 91 b4 04 	lds	r23, 0x04B4
 61a:	80 91 79 04 	lds	r24, 0x0479
 61e:	90 91 7a 04 	lds	r25, 0x047A
 622:	6e 5f       	subi	r22, 0xFE	; 254
 624:	7f 4f       	sbci	r23, 0xFF	; 255
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 626:	df 91       	pop	r29
 628:	cf 91       	pop	r28
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 62a:	0c 94 9e 02 	jmp	0x53c	; 0x53c <vListInsert>
 62e:	ec 01       	movw	r28, r24
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 630:	60 91 b3 04 	lds	r22, 0x04B3
 634:	70 91 b4 04 	lds	r23, 0x04B4
 638:	80 91 7b 04 	lds	r24, 0x047B
 63c:	90 91 7c 04 	lds	r25, 0x047C
 640:	6e 5f       	subi	r22, 0xFE	; 254
 642:	7f 4f       	sbci	r23, 0xFF	; 255
 644:	0e 94 9e 02 	call	0x53c	; 0x53c <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 648:	80 91 00 01 	lds	r24, 0x0100
 64c:	90 91 01 01 	lds	r25, 0x0101
 650:	c8 17       	cp	r28, r24
 652:	d9 07       	cpc	r29, r25
 654:	20 f4       	brcc	.+8      	; 0x65e <prvAddCurrentTaskToDelayedList+0x6a>
		{
			xNextTaskUnblockTime = xTimeToWake;
 656:	d0 93 01 01 	sts	0x0101, r29
 65a:	c0 93 00 01 	sts	0x0100, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 65e:	df 91       	pop	r29
 660:	cf 91       	pop	r28
 662:	08 95       	ret

00000664 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 664:	5f 92       	push	r5
 666:	6f 92       	push	r6
 668:	7f 92       	push	r7
 66a:	8f 92       	push	r8
 66c:	9f 92       	push	r9
 66e:	af 92       	push	r10
 670:	bf 92       	push	r11
 672:	cf 92       	push	r12
 674:	df 92       	push	r13
 676:	ef 92       	push	r14
 678:	ff 92       	push	r15
 67a:	0f 93       	push	r16
 67c:	1f 93       	push	r17
 67e:	cf 93       	push	r28
 680:	df 93       	push	r29
 682:	4c 01       	movw	r8, r24
 684:	16 2f       	mov	r17, r22
 686:	57 2e       	mov	r5, r23
 688:	5a 01       	movw	r10, r20
 68a:	39 01       	movw	r6, r18
{
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 68c:	81 e2       	ldi	r24, 0x21	; 33
 68e:	90 e0       	ldi	r25, 0x00	; 0
 690:	0e 94 38 02 	call	0x470	; 0x470 <pvPortMalloc>
 694:	ec 01       	movw	r28, r24

	if( pxNewTCB != NULL )
 696:	89 2b       	or	r24, r25
 698:	79 f0       	breq	.+30     	; 0x6b8 <xTaskGenericCreate+0x54>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 69a:	c1 14       	cp	r12, r1
 69c:	d1 04       	cpc	r13, r1
 69e:	21 f4       	brne	.+8      	; 0x6a8 <xTaskGenericCreate+0x44>
 6a0:	c5 01       	movw	r24, r10
 6a2:	0e 94 38 02 	call	0x470	; 0x470 <pvPortMalloc>
 6a6:	01 c0       	rjmp	.+2      	; 0x6aa <xTaskGenericCreate+0x46>
 6a8:	c6 01       	movw	r24, r12
 6aa:	98 8f       	std	Y+24, r25	; 0x18
 6ac:	8f 8b       	std	Y+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
 6ae:	00 97       	sbiw	r24, 0x00	; 0
 6b0:	29 f4       	brne	.+10     	; 0x6bc <xTaskGenericCreate+0x58>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 6b2:	ce 01       	movw	r24, r28
 6b4:	0e 94 6a 02 	call	0x4d4	; 0x4d4 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 6b8:	8f ef       	ldi	r24, 0xFF	; 255
 6ba:	b3 c0       	rjmp	.+358    	; 0x822 <xTaskGenericCreate+0x1be>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 6bc:	21 e0       	ldi	r18, 0x01	; 1
 6be:	a2 1a       	sub	r10, r18
 6c0:	b1 08       	sbc	r11, r1
 6c2:	a8 0e       	add	r10, r24
 6c4:	b9 1e       	adc	r11, r25
 6c6:	be 01       	movw	r22, r28
 6c8:	67 5e       	subi	r22, 0xE7	; 231
 6ca:	7f 4f       	sbci	r23, 0xFF	; 255
 6cc:	e1 2f       	mov	r30, r17
 6ce:	f5 2d       	mov	r31, r5
 6d0:	cf 01       	movw	r24, r30
 6d2:	08 96       	adiw	r24, 0x08	; 8
 6d4:	9f 01       	movw	r18, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 6d6:	41 91       	ld	r20, Z+
 6d8:	db 01       	movw	r26, r22
 6da:	4d 93       	st	X+, r20
 6dc:	bd 01       	movw	r22, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 6de:	d9 01       	movw	r26, r18
 6e0:	2c 91       	ld	r18, X
 6e2:	22 23       	and	r18, r18
 6e4:	19 f0       	breq	.+6      	; 0x6ec <xTaskGenericCreate+0x88>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 6e6:	e8 17       	cp	r30, r24
 6e8:	f9 07       	cpc	r31, r25
 6ea:	a1 f7       	brne	.-24     	; 0x6d4 <xTaskGenericCreate+0x70>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 6ec:	18 a2       	std	Y+32, r1	; 0x20
 6ee:	10 2f       	mov	r17, r16
 6f0:	04 30       	cpi	r16, 0x04	; 4
 6f2:	08 f0       	brcs	.+2      	; 0x6f6 <xTaskGenericCreate+0x92>
 6f4:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 6f6:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 6f8:	6e 01       	movw	r12, r28
 6fa:	b2 e0       	ldi	r27, 0x02	; 2
 6fc:	cb 0e       	add	r12, r27
 6fe:	d1 1c       	adc	r13, r1
 700:	c6 01       	movw	r24, r12
 702:	0e 94 79 02 	call	0x4f2	; 0x4f2 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 706:	ce 01       	movw	r24, r28
 708:	0c 96       	adiw	r24, 0x0c	; 12
 70a:	0e 94 79 02 	call	0x4f2	; 0x4f2 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 70e:	d9 87       	std	Y+9, r29	; 0x09
 710:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 712:	84 e0       	ldi	r24, 0x04	; 4
 714:	90 e0       	ldi	r25, 0x00	; 0
 716:	81 1b       	sub	r24, r17
 718:	91 09       	sbc	r25, r1
 71a:	9d 87       	std	Y+13, r25	; 0x0d
 71c:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 71e:	db 8b       	std	Y+19, r29	; 0x13
 720:	ca 8b       	std	Y+18, r28	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 722:	a3 01       	movw	r20, r6
 724:	b4 01       	movw	r22, r8
 726:	c5 01       	movw	r24, r10
 728:	0e 94 da 00 	call	0x1b4	; 0x1b4 <pxPortInitialiseStack>
 72c:	99 83       	std	Y+1, r25	; 0x01
 72e:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 730:	e1 14       	cp	r14, r1
 732:	f1 04       	cpc	r15, r1
 734:	19 f0       	breq	.+6      	; 0x73c <xTaskGenericCreate+0xd8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 736:	f7 01       	movw	r30, r14
 738:	d1 83       	std	Z+1, r29	; 0x01
 73a:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 73c:	0f b6       	in	r0, 0x3f	; 63
 73e:	f8 94       	cli
 740:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
 742:	80 91 6f 04 	lds	r24, 0x046F
 746:	8f 5f       	subi	r24, 0xFF	; 255
 748:	80 93 6f 04 	sts	0x046F, r24
			if( pxCurrentTCB == NULL )
 74c:	80 91 b3 04 	lds	r24, 0x04B3
 750:	90 91 b4 04 	lds	r25, 0x04B4
 754:	89 2b       	or	r24, r25
 756:	89 f5       	brne	.+98     	; 0x7ba <xTaskGenericCreate+0x156>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 758:	d0 93 b4 04 	sts	0x04B4, r29
 75c:	c0 93 b3 04 	sts	0x04B3, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 760:	80 91 6f 04 	lds	r24, 0x046F
 764:	81 30       	cpi	r24, 0x01	; 1
 766:	c1 f5       	brne	.+112    	; 0x7d8 <xTaskGenericCreate+0x174>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 768:	8f e8       	ldi	r24, 0x8F	; 143
 76a:	94 e0       	ldi	r25, 0x04	; 4
 76c:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <vListInitialise>
 770:	88 e9       	ldi	r24, 0x98	; 152
 772:	94 e0       	ldi	r25, 0x04	; 4
 774:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <vListInitialise>
 778:	81 ea       	ldi	r24, 0xA1	; 161
 77a:	94 e0       	ldi	r25, 0x04	; 4
 77c:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <vListInitialise>
 780:	8a ea       	ldi	r24, 0xAA	; 170
 782:	94 e0       	ldi	r25, 0x04	; 4
 784:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
 788:	86 e8       	ldi	r24, 0x86	; 134
 78a:	94 e0       	ldi	r25, 0x04	; 4
 78c:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 790:	8d e7       	ldi	r24, 0x7D	; 125
 792:	94 e0       	ldi	r25, 0x04	; 4
 794:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 798:	80 e7       	ldi	r24, 0x70	; 112
 79a:	94 e0       	ldi	r25, 0x04	; 4
 79c:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 7a0:	86 e8       	ldi	r24, 0x86	; 134
 7a2:	94 e0       	ldi	r25, 0x04	; 4
 7a4:	90 93 7c 04 	sts	0x047C, r25
 7a8:	80 93 7b 04 	sts	0x047B, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 7ac:	8d e7       	ldi	r24, 0x7D	; 125
 7ae:	94 e0       	ldi	r25, 0x04	; 4
 7b0:	90 93 7a 04 	sts	0x047A, r25
 7b4:	80 93 79 04 	sts	0x0479, r24
 7b8:	0f c0       	rjmp	.+30     	; 0x7d8 <xTaskGenericCreate+0x174>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 7ba:	80 91 6b 04 	lds	r24, 0x046B
 7be:	81 11       	cpse	r24, r1
 7c0:	0b c0       	rjmp	.+22     	; 0x7d8 <xTaskGenericCreate+0x174>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 7c2:	e0 91 b3 04 	lds	r30, 0x04B3
 7c6:	f0 91 b4 04 	lds	r31, 0x04B4
 7ca:	86 89       	ldd	r24, Z+22	; 0x16
 7cc:	08 17       	cp	r16, r24
 7ce:	20 f0       	brcs	.+8      	; 0x7d8 <xTaskGenericCreate+0x174>
					{
						pxCurrentTCB = pxNewTCB;
 7d0:	d0 93 b4 04 	sts	0x04B4, r29
 7d4:	c0 93 b3 04 	sts	0x04B3, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 7d8:	80 91 67 04 	lds	r24, 0x0467
 7dc:	8f 5f       	subi	r24, 0xFF	; 255
 7de:	80 93 67 04 	sts	0x0467, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 7e2:	8e 89       	ldd	r24, Y+22	; 0x16
 7e4:	90 91 6c 04 	lds	r25, 0x046C
 7e8:	98 17       	cp	r25, r24
 7ea:	10 f4       	brcc	.+4      	; 0x7f0 <xTaskGenericCreate+0x18c>
 7ec:	80 93 6c 04 	sts	0x046C, r24
 7f0:	f9 e0       	ldi	r31, 0x09	; 9
 7f2:	8f 9f       	mul	r24, r31
 7f4:	c0 01       	movw	r24, r0
 7f6:	11 24       	eor	r1, r1
 7f8:	b6 01       	movw	r22, r12
 7fa:	81 57       	subi	r24, 0x71	; 113
 7fc:	9b 4f       	sbci	r25, 0xFB	; 251
 7fe:	0e 94 7d 02 	call	0x4fa	; 0x4fa <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 802:	0f 90       	pop	r0
 804:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 806:	80 91 6b 04 	lds	r24, 0x046B
 80a:	88 23       	and	r24, r24
 80c:	49 f0       	breq	.+18     	; 0x820 <xTaskGenericCreate+0x1bc>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 80e:	e0 91 b3 04 	lds	r30, 0x04B3
 812:	f0 91 b4 04 	lds	r31, 0x04B4
 816:	86 89       	ldd	r24, Z+22	; 0x16
 818:	80 17       	cp	r24, r16
 81a:	10 f4       	brcc	.+4      	; 0x820 <xTaskGenericCreate+0x1bc>
			{
				taskYIELD_IF_USING_PREEMPTION();
 81c:	0e 94 80 01 	call	0x300	; 0x300 <vPortYield>
 820:	81 e0       	ldi	r24, 0x01	; 1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 822:	df 91       	pop	r29
 824:	cf 91       	pop	r28
 826:	1f 91       	pop	r17
 828:	0f 91       	pop	r16
 82a:	ff 90       	pop	r15
 82c:	ef 90       	pop	r14
 82e:	df 90       	pop	r13
 830:	cf 90       	pop	r12
 832:	bf 90       	pop	r11
 834:	af 90       	pop	r10
 836:	9f 90       	pop	r9
 838:	8f 90       	pop	r8
 83a:	7f 90       	pop	r7
 83c:	6f 90       	pop	r6
 83e:	5f 90       	pop	r5
 840:	08 95       	ret

00000842 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 842:	af 92       	push	r10
 844:	bf 92       	push	r11
 846:	cf 92       	push	r12
 848:	df 92       	push	r13
 84a:	ef 92       	push	r14
 84c:	ff 92       	push	r15
 84e:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 850:	a1 2c       	mov	r10, r1
 852:	b1 2c       	mov	r11, r1
 854:	c1 2c       	mov	r12, r1
 856:	d1 2c       	mov	r13, r1
 858:	e1 2c       	mov	r14, r1
 85a:	f1 2c       	mov	r15, r1
 85c:	00 e0       	ldi	r16, 0x00	; 0
 85e:	20 e0       	ldi	r18, 0x00	; 0
 860:	30 e0       	ldi	r19, 0x00	; 0
 862:	45 e5       	ldi	r20, 0x55	; 85
 864:	50 e0       	ldi	r21, 0x00	; 0
 866:	6b e0       	ldi	r22, 0x0B	; 11
 868:	71 e0       	ldi	r23, 0x01	; 1
 86a:	89 ef       	ldi	r24, 0xF9	; 249
 86c:	92 e0       	ldi	r25, 0x02	; 2
 86e:	0e 94 32 03 	call	0x664	; 0x664 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 872:	81 30       	cpi	r24, 0x01	; 1
 874:	81 f4       	brne	.+32     	; 0x896 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 876:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 878:	80 93 6b 04 	sts	0x046B, r24
		xTickCount = ( TickType_t ) 0U;
 87c:	10 92 6e 04 	sts	0x046E, r1
 880:	10 92 6d 04 	sts	0x046D, r1
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 884:	0f 91       	pop	r16
 886:	ff 90       	pop	r15
 888:	ef 90       	pop	r14
 88a:	df 90       	pop	r13
 88c:	cf 90       	pop	r12
 88e:	bf 90       	pop	r11
 890:	af 90       	pop	r10
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 892:	0c 94 46 01 	jmp	0x28c	; 0x28c <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 896:	0f 91       	pop	r16
 898:	ff 90       	pop	r15
 89a:	ef 90       	pop	r14
 89c:	df 90       	pop	r13
 89e:	cf 90       	pop	r12
 8a0:	bf 90       	pop	r11
 8a2:	af 90       	pop	r10
 8a4:	08 95       	ret

000008a6 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8a6:	80 91 66 04 	lds	r24, 0x0466
 8aa:	8f 5f       	subi	r24, 0xFF	; 255
 8ac:	80 93 66 04 	sts	0x0466, r24
 8b0:	08 95       	ret

000008b2 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8b2:	cf 92       	push	r12
 8b4:	df 92       	push	r13
 8b6:	ef 92       	push	r14
 8b8:	ff 92       	push	r15
 8ba:	0f 93       	push	r16
 8bc:	1f 93       	push	r17
 8be:	cf 93       	push	r28
 8c0:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8c2:	80 91 66 04 	lds	r24, 0x0466
 8c6:	81 11       	cpse	r24, r1
 8c8:	a7 c0       	rjmp	.+334    	; 0xa18 <__stack+0x119>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 8ca:	80 91 6d 04 	lds	r24, 0x046D
 8ce:	90 91 6e 04 	lds	r25, 0x046E
 8d2:	01 96       	adiw	r24, 0x01	; 1
 8d4:	90 93 6e 04 	sts	0x046E, r25
 8d8:	80 93 6d 04 	sts	0x046D, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 8dc:	e0 90 6d 04 	lds	r14, 0x046D
 8e0:	f0 90 6e 04 	lds	r15, 0x046E

			if( xConstTickCount == ( TickType_t ) 0U )
 8e4:	e1 14       	cp	r14, r1
 8e6:	f1 04       	cpc	r15, r1
 8e8:	79 f5       	brne	.+94     	; 0x948 <__stack+0x49>
			{
				taskSWITCH_DELAYED_LISTS();
 8ea:	80 91 7b 04 	lds	r24, 0x047B
 8ee:	90 91 7c 04 	lds	r25, 0x047C
 8f2:	20 91 79 04 	lds	r18, 0x0479
 8f6:	30 91 7a 04 	lds	r19, 0x047A
 8fa:	30 93 7c 04 	sts	0x047C, r19
 8fe:	20 93 7b 04 	sts	0x047B, r18
 902:	90 93 7a 04 	sts	0x047A, r25
 906:	80 93 79 04 	sts	0x0479, r24
 90a:	80 91 68 04 	lds	r24, 0x0468
 90e:	8f 5f       	subi	r24, 0xFF	; 255
 910:	80 93 68 04 	sts	0x0468, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 914:	e0 91 7b 04 	lds	r30, 0x047B
 918:	f0 91 7c 04 	lds	r31, 0x047C
 91c:	80 81       	ld	r24, Z
 91e:	81 11       	cpse	r24, r1
 920:	03 c0       	rjmp	.+6      	; 0x928 <__stack+0x29>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 922:	8f ef       	ldi	r24, 0xFF	; 255
 924:	9f ef       	ldi	r25, 0xFF	; 255
 926:	0c c0       	rjmp	.+24     	; 0x940 <__stack+0x41>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 928:	e0 91 7b 04 	lds	r30, 0x047B
 92c:	f0 91 7c 04 	lds	r31, 0x047C
 930:	05 80       	ldd	r0, Z+5	; 0x05
 932:	f6 81       	ldd	r31, Z+6	; 0x06
 934:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 936:	06 80       	ldd	r0, Z+6	; 0x06
 938:	f7 81       	ldd	r31, Z+7	; 0x07
 93a:	e0 2d       	mov	r30, r0
 93c:	82 81       	ldd	r24, Z+2	; 0x02
 93e:	93 81       	ldd	r25, Z+3	; 0x03
 940:	90 93 01 01 	sts	0x0101, r25
 944:	80 93 00 01 	sts	0x0100, r24

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 948:	80 91 00 01 	lds	r24, 0x0100
 94c:	90 91 01 01 	lds	r25, 0x0101
 950:	c0 e0       	ldi	r28, 0x00	; 0
 952:	e8 16       	cp	r14, r24
 954:	f9 06       	cpc	r15, r25
 956:	08 f4       	brcc	.+2      	; 0x95a <__stack+0x5b>
 958:	4f c0       	rjmp	.+158    	; 0x9f8 <__stack+0xf9>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 95a:	d9 e0       	ldi	r29, 0x09	; 9
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 95c:	e0 91 7b 04 	lds	r30, 0x047B
 960:	f0 91 7c 04 	lds	r31, 0x047C
 964:	80 81       	ld	r24, Z
 966:	81 11       	cpse	r24, r1
 968:	03 c0       	rjmp	.+6      	; 0x970 <__stack+0x71>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 96a:	8f ef       	ldi	r24, 0xFF	; 255
 96c:	9f ef       	ldi	r25, 0xFF	; 255
 96e:	11 c0       	rjmp	.+34     	; 0x992 <__stack+0x93>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 970:	e0 91 7b 04 	lds	r30, 0x047B
 974:	f0 91 7c 04 	lds	r31, 0x047C
 978:	05 80       	ldd	r0, Z+5	; 0x05
 97a:	f6 81       	ldd	r31, Z+6	; 0x06
 97c:	e0 2d       	mov	r30, r0
 97e:	06 81       	ldd	r16, Z+6	; 0x06
 980:	17 81       	ldd	r17, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 982:	d8 01       	movw	r26, r16
 984:	12 96       	adiw	r26, 0x02	; 2
 986:	8d 91       	ld	r24, X+
 988:	9c 91       	ld	r25, X
 98a:	13 97       	sbiw	r26, 0x03	; 3

						if( xConstTickCount < xItemValue )
 98c:	e8 16       	cp	r14, r24
 98e:	f9 06       	cpc	r15, r25
 990:	28 f4       	brcc	.+10     	; 0x99c <__stack+0x9d>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 992:	90 93 01 01 	sts	0x0101, r25
 996:	80 93 00 01 	sts	0x0100, r24
							break;
 99a:	2e c0       	rjmp	.+92     	; 0x9f8 <__stack+0xf9>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 99c:	68 01       	movw	r12, r16
 99e:	b2 e0       	ldi	r27, 0x02	; 2
 9a0:	cb 0e       	add	r12, r27
 9a2:	d1 1c       	adc	r13, r1
 9a4:	c6 01       	movw	r24, r12
 9a6:	0e 94 d6 02 	call	0x5ac	; 0x5ac <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 9aa:	f8 01       	movw	r30, r16
 9ac:	84 89       	ldd	r24, Z+20	; 0x14
 9ae:	95 89       	ldd	r25, Z+21	; 0x15
 9b0:	89 2b       	or	r24, r25
 9b2:	21 f0       	breq	.+8      	; 0x9bc <__stack+0xbd>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 9b4:	c8 01       	movw	r24, r16
 9b6:	0c 96       	adiw	r24, 0x0c	; 12
 9b8:	0e 94 d6 02 	call	0x5ac	; 0x5ac <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 9bc:	d8 01       	movw	r26, r16
 9be:	56 96       	adiw	r26, 0x16	; 22
 9c0:	9c 91       	ld	r25, X
 9c2:	80 91 6c 04 	lds	r24, 0x046C
 9c6:	89 17       	cp	r24, r25
 9c8:	10 f4       	brcc	.+4      	; 0x9ce <__stack+0xcf>
 9ca:	90 93 6c 04 	sts	0x046C, r25
 9ce:	d9 9f       	mul	r29, r25
 9d0:	c0 01       	movw	r24, r0
 9d2:	11 24       	eor	r1, r1
 9d4:	b6 01       	movw	r22, r12
 9d6:	81 57       	subi	r24, 0x71	; 113
 9d8:	9b 4f       	sbci	r25, 0xFB	; 251
 9da:	0e 94 7d 02 	call	0x4fa	; 0x4fa <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 9de:	e0 91 b3 04 	lds	r30, 0x04B3
 9e2:	f0 91 b4 04 	lds	r31, 0x04B4
 9e6:	d8 01       	movw	r26, r16
 9e8:	56 96       	adiw	r26, 0x16	; 22
 9ea:	9c 91       	ld	r25, X
 9ec:	86 89       	ldd	r24, Z+22	; 0x16
 9ee:	98 17       	cp	r25, r24
 9f0:	08 f4       	brcc	.+2      	; 0x9f4 <__stack+0xf5>
 9f2:	b4 cf       	rjmp	.-152    	; 0x95c <__stack+0x5d>
							{
								xSwitchRequired = pdTRUE;
 9f4:	c1 e0       	ldi	r28, 0x01	; 1
 9f6:	b2 cf       	rjmp	.-156    	; 0x95c <__stack+0x5d>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 9f8:	e0 91 b3 04 	lds	r30, 0x04B3
 9fc:	f0 91 b4 04 	lds	r31, 0x04B4
 a00:	e6 89       	ldd	r30, Z+22	; 0x16
 a02:	b9 e0       	ldi	r27, 0x09	; 9
 a04:	eb 9f       	mul	r30, r27
 a06:	f0 01       	movw	r30, r0
 a08:	11 24       	eor	r1, r1
 a0a:	e1 57       	subi	r30, 0x71	; 113
 a0c:	fb 4f       	sbci	r31, 0xFB	; 251
 a0e:	80 81       	ld	r24, Z
 a10:	82 30       	cpi	r24, 0x02	; 2
 a12:	40 f0       	brcs	.+16     	; 0xa24 <__stack+0x125>
			{
				xSwitchRequired = pdTRUE;
 a14:	c1 e0       	ldi	r28, 0x01	; 1
 a16:	06 c0       	rjmp	.+12     	; 0xa24 <__stack+0x125>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 a18:	80 91 6a 04 	lds	r24, 0x046A
 a1c:	8f 5f       	subi	r24, 0xFF	; 255
 a1e:	80 93 6a 04 	sts	0x046A, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 a22:	c0 e0       	ldi	r28, 0x00	; 0
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 a24:	80 91 69 04 	lds	r24, 0x0469
 a28:	81 11       	cpse	r24, r1
		{
			xSwitchRequired = pdTRUE;
 a2a:	c1 e0       	ldi	r28, 0x01	; 1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 a2c:	8c 2f       	mov	r24, r28
 a2e:	df 91       	pop	r29
 a30:	cf 91       	pop	r28
 a32:	1f 91       	pop	r17
 a34:	0f 91       	pop	r16
 a36:	ff 90       	pop	r15
 a38:	ef 90       	pop	r14
 a3a:	df 90       	pop	r13
 a3c:	cf 90       	pop	r12
 a3e:	08 95       	ret

00000a40 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 a40:	ef 92       	push	r14
 a42:	ff 92       	push	r15
 a44:	0f 93       	push	r16
 a46:	1f 93       	push	r17
 a48:	cf 93       	push	r28
 a4a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 a4c:	0f b6       	in	r0, 0x3f	; 63
 a4e:	f8 94       	cli
 a50:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 a52:	80 91 66 04 	lds	r24, 0x0466
 a56:	81 50       	subi	r24, 0x01	; 1
 a58:	80 93 66 04 	sts	0x0466, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 a5c:	80 91 66 04 	lds	r24, 0x0466
 a60:	88 23       	and	r24, r24
 a62:	11 f0       	breq	.+4      	; 0xa68 <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 a64:	80 e0       	ldi	r24, 0x00	; 0
 a66:	53 c0       	rjmp	.+166    	; 0xb0e <xTaskResumeAll+0xce>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 a68:	80 91 6f 04 	lds	r24, 0x046F
 a6c:	88 23       	and	r24, r24
 a6e:	d1 f3       	breq	.-12     	; 0xa64 <xTaskResumeAll+0x24>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyList( pxTCB );
 a70:	89 e0       	ldi	r24, 0x09	; 9
 a72:	f8 2e       	mov	r15, r24

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 a74:	ee 24       	eor	r14, r14
 a76:	e3 94       	inc	r14
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 a78:	80 91 70 04 	lds	r24, 0x0470
 a7c:	88 23       	and	r24, r24
 a7e:	51 f1       	breq	.+84     	; 0xad4 <xTaskResumeAll+0x94>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 a80:	e0 91 75 04 	lds	r30, 0x0475
 a84:	f0 91 76 04 	lds	r31, 0x0476
 a88:	c6 81       	ldd	r28, Z+6	; 0x06
 a8a:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 a8c:	ce 01       	movw	r24, r28
 a8e:	0c 96       	adiw	r24, 0x0c	; 12
 a90:	0e 94 d6 02 	call	0x5ac	; 0x5ac <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 a94:	8e 01       	movw	r16, r28
 a96:	0e 5f       	subi	r16, 0xFE	; 254
 a98:	1f 4f       	sbci	r17, 0xFF	; 255
 a9a:	c8 01       	movw	r24, r16
 a9c:	0e 94 d6 02 	call	0x5ac	; 0x5ac <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 aa0:	9e 89       	ldd	r25, Y+22	; 0x16
 aa2:	80 91 6c 04 	lds	r24, 0x046C
 aa6:	89 17       	cp	r24, r25
 aa8:	10 f4       	brcc	.+4      	; 0xaae <xTaskResumeAll+0x6e>
 aaa:	90 93 6c 04 	sts	0x046C, r25
 aae:	f9 9e       	mul	r15, r25
 ab0:	c0 01       	movw	r24, r0
 ab2:	11 24       	eor	r1, r1
 ab4:	b8 01       	movw	r22, r16
 ab6:	81 57       	subi	r24, 0x71	; 113
 ab8:	9b 4f       	sbci	r25, 0xFB	; 251
 aba:	0e 94 7d 02 	call	0x4fa	; 0x4fa <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 abe:	e0 91 b3 04 	lds	r30, 0x04B3
 ac2:	f0 91 b4 04 	lds	r31, 0x04B4
 ac6:	9e 89       	ldd	r25, Y+22	; 0x16
 ac8:	86 89       	ldd	r24, Z+22	; 0x16
 aca:	98 17       	cp	r25, r24
 acc:	a8 f2       	brcs	.-86     	; 0xa78 <xTaskResumeAll+0x38>
					{
						xYieldPending = pdTRUE;
 ace:	e0 92 69 04 	sts	0x0469, r14
 ad2:	d2 cf       	rjmp	.-92     	; 0xa78 <xTaskResumeAll+0x38>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 ad4:	80 91 6a 04 	lds	r24, 0x046A
 ad8:	81 11       	cpse	r24, r1
 ada:	09 c0       	rjmp	.+18     	; 0xaee <xTaskResumeAll+0xae>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 adc:	80 91 69 04 	lds	r24, 0x0469
 ae0:	81 30       	cpi	r24, 0x01	; 1
 ae2:	09 f0       	breq	.+2      	; 0xae6 <xTaskResumeAll+0xa6>
 ae4:	bf cf       	rjmp	.-130    	; 0xa64 <xTaskResumeAll+0x24>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 ae6:	0e 94 80 01 	call	0x300	; 0x300 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 aea:	81 e0       	ldi	r24, 0x01	; 1
 aec:	10 c0       	rjmp	.+32     	; 0xb0e <xTaskResumeAll+0xce>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 aee:	c1 e0       	ldi	r28, 0x01	; 1
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 af0:	80 91 6a 04 	lds	r24, 0x046A
 af4:	88 23       	and	r24, r24
 af6:	91 f3       	breq	.-28     	; 0xadc <xTaskResumeAll+0x9c>
					{
						if( xTaskIncrementTick() != pdFALSE )
 af8:	0e 94 59 04 	call	0x8b2	; 0x8b2 <xTaskIncrementTick>
 afc:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
 afe:	c0 93 69 04 	sts	0x0469, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 b02:	80 91 6a 04 	lds	r24, 0x046A
 b06:	81 50       	subi	r24, 0x01	; 1
 b08:	80 93 6a 04 	sts	0x046A, r24
 b0c:	f1 cf       	rjmp	.-30     	; 0xaf0 <xTaskResumeAll+0xb0>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 b0e:	0f 90       	pop	r0
 b10:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 b12:	df 91       	pop	r29
 b14:	cf 91       	pop	r28
 b16:	1f 91       	pop	r17
 b18:	0f 91       	pop	r16
 b1a:	ff 90       	pop	r15
 b1c:	ef 90       	pop	r14
 b1e:	08 95       	ret

00000b20 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 b20:	cf 93       	push	r28
 b22:	df 93       	push	r29
 b24:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 b26:	89 2b       	or	r24, r25
 b28:	19 f4       	brne	.+6      	; 0xb30 <vTaskDelay+0x10>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 b2a:	0e 94 80 01 	call	0x300	; 0x300 <vPortYield>
 b2e:	16 c0       	rjmp	.+44     	; 0xb5c <vTaskDelay+0x3c>

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 b30:	0e 94 53 04 	call	0x8a6	; 0x8a6 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 b34:	20 91 6d 04 	lds	r18, 0x046D
 b38:	30 91 6e 04 	lds	r19, 0x046E
 b3c:	c2 0f       	add	r28, r18
 b3e:	d3 1f       	adc	r29, r19

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 b40:	80 91 b3 04 	lds	r24, 0x04B3
 b44:	90 91 b4 04 	lds	r25, 0x04B4
 b48:	02 96       	adiw	r24, 0x02	; 2
 b4a:	0e 94 d6 02 	call	0x5ac	; 0x5ac <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 b4e:	ce 01       	movw	r24, r28
 b50:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 b54:	0e 94 20 05 	call	0xa40	; 0xa40 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 b58:	88 23       	and	r24, r24
 b5a:	39 f3       	breq	.-50     	; 0xb2a <vTaskDelay+0xa>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 b5c:	df 91       	pop	r29
 b5e:	cf 91       	pop	r28
 b60:	08 95       	ret

00000b62 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 b62:	80 91 66 04 	lds	r24, 0x0466
 b66:	88 23       	and	r24, r24
 b68:	21 f0       	breq	.+8      	; 0xb72 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 b6a:	81 e0       	ldi	r24, 0x01	; 1
 b6c:	80 93 69 04 	sts	0x0469, r24
 b70:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 b72:	10 92 69 04 	sts	0x0469, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 b76:	99 e0       	ldi	r25, 0x09	; 9
 b78:	e0 91 6c 04 	lds	r30, 0x046C
 b7c:	9e 9f       	mul	r25, r30
 b7e:	f0 01       	movw	r30, r0
 b80:	11 24       	eor	r1, r1
 b82:	e1 57       	subi	r30, 0x71	; 113
 b84:	fb 4f       	sbci	r31, 0xFB	; 251
 b86:	80 81       	ld	r24, Z
 b88:	81 11       	cpse	r24, r1
 b8a:	06 c0       	rjmp	.+12     	; 0xb98 <vTaskSwitchContext+0x36>
 b8c:	80 91 6c 04 	lds	r24, 0x046C
 b90:	81 50       	subi	r24, 0x01	; 1
 b92:	80 93 6c 04 	sts	0x046C, r24
 b96:	f0 cf       	rjmp	.-32     	; 0xb78 <vTaskSwitchContext+0x16>
 b98:	80 91 6c 04 	lds	r24, 0x046C
 b9c:	90 e0       	ldi	r25, 0x00	; 0
 b9e:	49 e0       	ldi	r20, 0x09	; 9
 ba0:	48 9f       	mul	r20, r24
 ba2:	90 01       	movw	r18, r0
 ba4:	49 9f       	mul	r20, r25
 ba6:	30 0d       	add	r19, r0
 ba8:	11 24       	eor	r1, r1
 baa:	f9 01       	movw	r30, r18
 bac:	e1 57       	subi	r30, 0x71	; 113
 bae:	fb 4f       	sbci	r31, 0xFB	; 251
 bb0:	a1 81       	ldd	r26, Z+1	; 0x01
 bb2:	b2 81       	ldd	r27, Z+2	; 0x02
 bb4:	12 96       	adiw	r26, 0x02	; 2
 bb6:	0d 90       	ld	r0, X+
 bb8:	bc 91       	ld	r27, X
 bba:	a0 2d       	mov	r26, r0
 bbc:	b2 83       	std	Z+2, r27	; 0x02
 bbe:	a1 83       	std	Z+1, r26	; 0x01
 bc0:	2e 56       	subi	r18, 0x6E	; 110
 bc2:	3b 4f       	sbci	r19, 0xFB	; 251
 bc4:	a2 17       	cp	r26, r18
 bc6:	b3 07       	cpc	r27, r19
 bc8:	31 f4       	brne	.+12     	; 0xbd6 <vTaskSwitchContext+0x74>
 bca:	12 96       	adiw	r26, 0x02	; 2
 bcc:	2d 91       	ld	r18, X+
 bce:	3c 91       	ld	r19, X
 bd0:	13 97       	sbiw	r26, 0x03	; 3
 bd2:	32 83       	std	Z+2, r19	; 0x02
 bd4:	21 83       	std	Z+1, r18	; 0x01
 bd6:	29 e0       	ldi	r18, 0x09	; 9
 bd8:	28 9f       	mul	r18, r24
 bda:	f0 01       	movw	r30, r0
 bdc:	29 9f       	mul	r18, r25
 bde:	f0 0d       	add	r31, r0
 be0:	11 24       	eor	r1, r1
 be2:	e1 57       	subi	r30, 0x71	; 113
 be4:	fb 4f       	sbci	r31, 0xFB	; 251
 be6:	01 80       	ldd	r0, Z+1	; 0x01
 be8:	f2 81       	ldd	r31, Z+2	; 0x02
 bea:	e0 2d       	mov	r30, r0
 bec:	86 81       	ldd	r24, Z+6	; 0x06
 bee:	97 81       	ldd	r25, Z+7	; 0x07
 bf0:	90 93 b4 04 	sts	0x04B4, r25
 bf4:	80 93 b3 04 	sts	0x04B3, r24
 bf8:	08 95       	ret

00000bfa <initVariant>:
int atexit(void (* /*func*/ )()) { return 0; }

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }
 bfa:	08 95       	ret

00000bfc <main>:
void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
	init();
 bfc:	0e 94 57 06 	call	0xcae	; 0xcae <init>

	initVariant();
 c00:	0e 94 fd 05 	call	0xbfa	; 0xbfa <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
 c04:	0e 94 a0 00 	call	0x140	; 0x140 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 c08:	c0 e0       	ldi	r28, 0x00	; 0
 c0a:	d0 e0       	ldi	r29, 0x00	; 0
#endif
	
	setup();
    
	for (;;) {
		loop();
 c0c:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <loop>
		if (serialEventRun) serialEventRun();
 c10:	20 97       	sbiw	r28, 0x00	; 0
 c12:	e1 f3       	breq	.-8      	; 0xc0c <main+0x10>
 c14:	0e 94 00 00 	call	0	; 0x0 <__vectors>
 c18:	f9 cf       	rjmp	.-14     	; 0xc0c <main+0x10>

00000c1a <__vector_16>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
 c1a:	1f 92       	push	r1
 c1c:	0f 92       	push	r0
 c1e:	0f b6       	in	r0, 0x3f	; 63
 c20:	0f 92       	push	r0
 c22:	11 24       	eor	r1, r1
 c24:	2f 93       	push	r18
 c26:	3f 93       	push	r19
 c28:	8f 93       	push	r24
 c2a:	9f 93       	push	r25
 c2c:	af 93       	push	r26
 c2e:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
 c30:	80 91 b6 04 	lds	r24, 0x04B6
 c34:	90 91 b7 04 	lds	r25, 0x04B7
 c38:	a0 91 b8 04 	lds	r26, 0x04B8
 c3c:	b0 91 b9 04 	lds	r27, 0x04B9
	unsigned char f = timer0_fract;
 c40:	30 91 b5 04 	lds	r19, 0x04B5

	m += MILLIS_INC;
	f += FRACT_INC;
 c44:	23 e0       	ldi	r18, 0x03	; 3
 c46:	23 0f       	add	r18, r19
	if (f >= FRACT_MAX) {
 c48:	2d 37       	cpi	r18, 0x7D	; 125
 c4a:	20 f4       	brcc	.+8      	; 0xc54 <__vector_16+0x3a>
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
	unsigned char f = timer0_fract;

	m += MILLIS_INC;
 c4c:	01 96       	adiw	r24, 0x01	; 1
 c4e:	a1 1d       	adc	r26, r1
 c50:	b1 1d       	adc	r27, r1
 c52:	05 c0       	rjmp	.+10     	; 0xc5e <__vector_16+0x44>
	f += FRACT_INC;
	if (f >= FRACT_MAX) {
		f -= FRACT_MAX;
 c54:	26 e8       	ldi	r18, 0x86	; 134
 c56:	23 0f       	add	r18, r19
		m += 1;
 c58:	02 96       	adiw	r24, 0x02	; 2
 c5a:	a1 1d       	adc	r26, r1
 c5c:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
 c5e:	20 93 b5 04 	sts	0x04B5, r18
	timer0_millis = m;
 c62:	80 93 b6 04 	sts	0x04B6, r24
 c66:	90 93 b7 04 	sts	0x04B7, r25
 c6a:	a0 93 b8 04 	sts	0x04B8, r26
 c6e:	b0 93 b9 04 	sts	0x04B9, r27
	timer0_overflow_count++;
 c72:	80 91 ba 04 	lds	r24, 0x04BA
 c76:	90 91 bb 04 	lds	r25, 0x04BB
 c7a:	a0 91 bc 04 	lds	r26, 0x04BC
 c7e:	b0 91 bd 04 	lds	r27, 0x04BD
 c82:	01 96       	adiw	r24, 0x01	; 1
 c84:	a1 1d       	adc	r26, r1
 c86:	b1 1d       	adc	r27, r1
 c88:	80 93 ba 04 	sts	0x04BA, r24
 c8c:	90 93 bb 04 	sts	0x04BB, r25
 c90:	a0 93 bc 04 	sts	0x04BC, r26
 c94:	b0 93 bd 04 	sts	0x04BD, r27
}
 c98:	bf 91       	pop	r27
 c9a:	af 91       	pop	r26
 c9c:	9f 91       	pop	r25
 c9e:	8f 91       	pop	r24
 ca0:	3f 91       	pop	r19
 ca2:	2f 91       	pop	r18
 ca4:	0f 90       	pop	r0
 ca6:	0f be       	out	0x3f, r0	; 63
 ca8:	0f 90       	pop	r0
 caa:	1f 90       	pop	r1
 cac:	18 95       	reti

00000cae <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 cae:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 cb0:	84 b5       	in	r24, 0x24	; 36
 cb2:	82 60       	ori	r24, 0x02	; 2
 cb4:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 cb6:	84 b5       	in	r24, 0x24	; 36
 cb8:	81 60       	ori	r24, 0x01	; 1
 cba:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 cbc:	85 b5       	in	r24, 0x25	; 37
 cbe:	82 60       	ori	r24, 0x02	; 2
 cc0:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 cc2:	85 b5       	in	r24, 0x25	; 37
 cc4:	81 60       	ori	r24, 0x01	; 1
 cc6:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 cc8:	ee e6       	ldi	r30, 0x6E	; 110
 cca:	f0 e0       	ldi	r31, 0x00	; 0
 ccc:	80 81       	ld	r24, Z
 cce:	81 60       	ori	r24, 0x01	; 1
 cd0:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 cd2:	e1 e8       	ldi	r30, 0x81	; 129
 cd4:	f0 e0       	ldi	r31, 0x00	; 0
 cd6:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 cd8:	80 81       	ld	r24, Z
 cda:	82 60       	ori	r24, 0x02	; 2
 cdc:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 cde:	80 81       	ld	r24, Z
 ce0:	81 60       	ori	r24, 0x01	; 1
 ce2:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 ce4:	e0 e8       	ldi	r30, 0x80	; 128
 ce6:	f0 e0       	ldi	r31, 0x00	; 0
 ce8:	80 81       	ld	r24, Z
 cea:	81 60       	ori	r24, 0x01	; 1
 cec:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 cee:	e1 eb       	ldi	r30, 0xB1	; 177
 cf0:	f0 e0       	ldi	r31, 0x00	; 0
 cf2:	80 81       	ld	r24, Z
 cf4:	84 60       	ori	r24, 0x04	; 4
 cf6:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 cf8:	e0 eb       	ldi	r30, 0xB0	; 176
 cfa:	f0 e0       	ldi	r31, 0x00	; 0
 cfc:	80 81       	ld	r24, Z
 cfe:	81 60       	ori	r24, 0x01	; 1
 d00:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 d02:	ea e7       	ldi	r30, 0x7A	; 122
 d04:	f0 e0       	ldi	r31, 0x00	; 0
 d06:	80 81       	ld	r24, Z
 d08:	84 60       	ori	r24, 0x04	; 4
 d0a:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
 d0c:	80 81       	ld	r24, Z
 d0e:	82 60       	ori	r24, 0x02	; 2
 d10:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
 d12:	80 81       	ld	r24, Z
 d14:	81 60       	ori	r24, 0x01	; 1
 d16:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 d18:	80 81       	ld	r24, Z
 d1a:	80 68       	ori	r24, 0x80	; 128
 d1c:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 d1e:	10 92 c1 00 	sts	0x00C1, r1
 d22:	08 95       	ret

00000d24 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 d24:	83 30       	cpi	r24, 0x03	; 3
 d26:	81 f0       	breq	.+32     	; 0xd48 <turnOffPWM+0x24>
 d28:	28 f4       	brcc	.+10     	; 0xd34 <turnOffPWM+0x10>
 d2a:	81 30       	cpi	r24, 0x01	; 1
 d2c:	99 f0       	breq	.+38     	; 0xd54 <turnOffPWM+0x30>
 d2e:	82 30       	cpi	r24, 0x02	; 2
 d30:	a1 f0       	breq	.+40     	; 0xd5a <turnOffPWM+0x36>
 d32:	08 95       	ret
 d34:	87 30       	cpi	r24, 0x07	; 7
 d36:	a9 f0       	breq	.+42     	; 0xd62 <turnOffPWM+0x3e>
 d38:	88 30       	cpi	r24, 0x08	; 8
 d3a:	b9 f0       	breq	.+46     	; 0xd6a <turnOffPWM+0x46>
 d3c:	84 30       	cpi	r24, 0x04	; 4
 d3e:	d1 f4       	brne	.+52     	; 0xd74 <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 d40:	80 91 80 00 	lds	r24, 0x0080
 d44:	8f 7d       	andi	r24, 0xDF	; 223
 d46:	03 c0       	rjmp	.+6      	; 0xd4e <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 d48:	80 91 80 00 	lds	r24, 0x0080
 d4c:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 d4e:	80 93 80 00 	sts	0x0080, r24
 d52:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 d54:	84 b5       	in	r24, 0x24	; 36
 d56:	8f 77       	andi	r24, 0x7F	; 127
 d58:	02 c0       	rjmp	.+4      	; 0xd5e <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 d5a:	84 b5       	in	r24, 0x24	; 36
 d5c:	8f 7d       	andi	r24, 0xDF	; 223
 d5e:	84 bd       	out	0x24, r24	; 36
 d60:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 d62:	80 91 b0 00 	lds	r24, 0x00B0
 d66:	8f 77       	andi	r24, 0x7F	; 127
 d68:	03 c0       	rjmp	.+6      	; 0xd70 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 d6a:	80 91 b0 00 	lds	r24, 0x00B0
 d6e:	8f 7d       	andi	r24, 0xDF	; 223
 d70:	80 93 b0 00 	sts	0x00B0, r24
 d74:	08 95       	ret

00000d76 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
 d76:	cf 93       	push	r28
 d78:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
 d7a:	90 e0       	ldi	r25, 0x00	; 0
 d7c:	fc 01       	movw	r30, r24
 d7e:	e4 58       	subi	r30, 0x84	; 132
 d80:	ff 4f       	sbci	r31, 0xFF	; 255
 d82:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
 d84:	fc 01       	movw	r30, r24
 d86:	e0 57       	subi	r30, 0x70	; 112
 d88:	ff 4f       	sbci	r31, 0xFF	; 255
 d8a:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 d8c:	88 23       	and	r24, r24
 d8e:	61 f1       	breq	.+88     	; 0xde8 <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 d90:	90 e0       	ldi	r25, 0x00	; 0
 d92:	88 0f       	add	r24, r24
 d94:	99 1f       	adc	r25, r25
 d96:	fc 01       	movw	r30, r24
 d98:	e2 55       	subi	r30, 0x52	; 82
 d9a:	ff 4f       	sbci	r31, 0xFF	; 255
 d9c:	c5 91       	lpm	r28, Z+
 d9e:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
 da0:	fc 01       	movw	r30, r24
 da2:	ec 55       	subi	r30, 0x5C	; 92
 da4:	ff 4f       	sbci	r31, 0xFF	; 255
 da6:	a5 91       	lpm	r26, Z+
 da8:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
 daa:	61 11       	cpse	r22, r1
 dac:	09 c0       	rjmp	.+18     	; 0xdc0 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
 dae:	9f b7       	in	r25, 0x3f	; 63
                cli();
 db0:	f8 94       	cli
		*reg &= ~bit;
 db2:	88 81       	ld	r24, Y
 db4:	20 95       	com	r18
 db6:	82 23       	and	r24, r18
 db8:	88 83       	st	Y, r24
		*out &= ~bit;
 dba:	ec 91       	ld	r30, X
 dbc:	2e 23       	and	r18, r30
 dbe:	0b c0       	rjmp	.+22     	; 0xdd6 <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
 dc0:	62 30       	cpi	r22, 0x02	; 2
 dc2:	61 f4       	brne	.+24     	; 0xddc <pinMode+0x66>
		uint8_t oldSREG = SREG;
 dc4:	9f b7       	in	r25, 0x3f	; 63
                cli();
 dc6:	f8 94       	cli
		*reg &= ~bit;
 dc8:	38 81       	ld	r19, Y
 dca:	82 2f       	mov	r24, r18
 dcc:	80 95       	com	r24
 dce:	83 23       	and	r24, r19
 dd0:	88 83       	st	Y, r24
		*out |= bit;
 dd2:	ec 91       	ld	r30, X
 dd4:	2e 2b       	or	r18, r30
 dd6:	2c 93       	st	X, r18
		SREG = oldSREG;
 dd8:	9f bf       	out	0x3f, r25	; 63
 dda:	06 c0       	rjmp	.+12     	; 0xde8 <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
 ddc:	8f b7       	in	r24, 0x3f	; 63
                cli();
 dde:	f8 94       	cli
		*reg |= bit;
 de0:	e8 81       	ld	r30, Y
 de2:	2e 2b       	or	r18, r30
 de4:	28 83       	st	Y, r18
		SREG = oldSREG;
 de6:	8f bf       	out	0x3f, r24	; 63
	}
}
 de8:	df 91       	pop	r29
 dea:	cf 91       	pop	r28
 dec:	08 95       	ret

00000dee <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
 dee:	1f 93       	push	r17
 df0:	cf 93       	push	r28
 df2:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
 df4:	28 2f       	mov	r18, r24
 df6:	30 e0       	ldi	r19, 0x00	; 0
 df8:	f9 01       	movw	r30, r18
 dfa:	e8 59       	subi	r30, 0x98	; 152
 dfc:	ff 4f       	sbci	r31, 0xFF	; 255
 dfe:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
 e00:	f9 01       	movw	r30, r18
 e02:	e4 58       	subi	r30, 0x84	; 132
 e04:	ff 4f       	sbci	r31, 0xFF	; 255
 e06:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
 e08:	f9 01       	movw	r30, r18
 e0a:	e0 57       	subi	r30, 0x70	; 112
 e0c:	ff 4f       	sbci	r31, 0xFF	; 255
 e0e:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 e10:	cc 23       	and	r28, r28
 e12:	c9 f0       	breq	.+50     	; 0xe46 <digitalWrite+0x58>
 e14:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 e16:	81 11       	cpse	r24, r1
 e18:	0e 94 92 06 	call	0xd24	; 0xd24 <turnOffPWM>

	out = portOutputRegister(port);
 e1c:	ec 2f       	mov	r30, r28
 e1e:	f0 e0       	ldi	r31, 0x00	; 0
 e20:	ee 0f       	add	r30, r30
 e22:	ff 1f       	adc	r31, r31
 e24:	ec 55       	subi	r30, 0x5C	; 92
 e26:	ff 4f       	sbci	r31, 0xFF	; 255
 e28:	a5 91       	lpm	r26, Z+
 e2a:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
 e2c:	8f b7       	in	r24, 0x3f	; 63
	cli();
 e2e:	f8 94       	cli

	if (val == LOW) {
 e30:	11 11       	cpse	r17, r1
 e32:	05 c0       	rjmp	.+10     	; 0xe3e <digitalWrite+0x50>
		*out &= ~bit;
 e34:	9c 91       	ld	r25, X
 e36:	ed 2f       	mov	r30, r29
 e38:	e0 95       	com	r30
 e3a:	e9 23       	and	r30, r25
 e3c:	02 c0       	rjmp	.+4      	; 0xe42 <digitalWrite+0x54>
	} else {
		*out |= bit;
 e3e:	ec 91       	ld	r30, X
 e40:	ed 2b       	or	r30, r29
 e42:	ec 93       	st	X, r30
	}

	SREG = oldSREG;
 e44:	8f bf       	out	0x3f, r24	; 63
}
 e46:	df 91       	pop	r29
 e48:	cf 91       	pop	r28
 e4a:	1f 91       	pop	r17
 e4c:	08 95       	ret

00000e4e <_exit>:
 e4e:	f8 94       	cli

00000e50 <__stop_program>:
 e50:	ff cf       	rjmp	.-2      	; 0xe50 <__stop_program>
